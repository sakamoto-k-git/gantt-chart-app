/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { afterEach, beforeEach, describe, it, jest } from '@jest/globals';
import { ErrorCodes, PowerDataRuntimeError } from '../internal/data/core/error/error';
import { RuntimeMetadataClient } from '../internal/data/core/runtimeClient/runtimeMetadataClient';
import { mockSilentLogger } from './mocks/mockLog';
import { silenceConsole } from './mocks/silenceConsole';
/* eslint-disable @typescript-eslint/no-explicit-any */
// Mock the telemetry log module to avoid actual logging during tests
jest.mock('../internal/data/core/telemetry/log', () => mockSilentLogger);
// return value for action :loadAppConnectionsAsync_v2 run through PowerOperationExecutor
const mockAppDataSourceConfigs = {
    success: true,
    data: {
        datasource1: {
            apiId: 'someApiId_dataSource1',
            connectionName: '01234567-8901-2345-6789-012345678901',
            runtimeUrl: 'https://contosso.org/1',
            error: undefined,
            datasetName: undefined,
        },
        datasource2: {
            apiId: 'someApiId_dataSource2',
            connectionName: '09876543-2109-8765-4321-098765432109',
            runtimeUrl: 'https://contosso.org/2',
            error: undefined,
            datasetName: undefined,
        },
    },
};
// return value for action :getAppCdsDataSourceConfigsAsync run through PowerOperationExecutor
const mockCdsAppDataSourceConfigs = {
    success: true,
    data: {
        datasource1: {
            runtimeUrl: 'https://contosso.org/1',
            entitySetName: 'someEntitySetName1',
            logicalName: 'someLogicalName1',
        },
        datasource2: {
            runtimeUrl: 'https://contosso.org/2',
            entitySetName: 'someEntitySetName2',
            logicalName: 'someLogicalName2',
        },
    },
};
describe('RuntimeMetadataClient', () => {
    let mockPowerOperationExecutor;
    // Console silencing setup - silence all console output for this test file
    let consoleMocks;
    beforeEach(() => {
        mockPowerOperationExecutor = {
            execute: jest.fn(),
        };
        consoleMocks = silenceConsole();
    });
    afterEach(() => {
        jest.clearAllMocks();
        consoleMocks.restore();
    });
    describe('createInstanceAsync - Static Factory Method', () => {
        it('should create instance successfully with valid executor', async () => {
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            expect(instance).toBeInstanceOf(RuntimeMetadataClient);
        });
        it('should handle null/undefined executor', async () => {
            await expect(RuntimeMetadataClient.createInstanceAsync(null)).resolves.toBeInstanceOf(RuntimeMetadataClient);
        });
    });
    describe('getAppConnectionConfigsAsync - Happy Path', () => {
        it('should return connection configurations successfully', async () => {
            mockPowerOperationExecutor.execute.mockResolvedValue(mockAppDataSourceConfigs);
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            const result = await instance.getAppConnectionConfigsAsync();
            expect(mockPowerOperationExecutor.execute).toHaveBeenCalledWith('AppPowerAppsClientPlugin', 'loadAppConnectionsAsync_v2', []);
            expect(result).toEqual(mockAppDataSourceConfigs);
        });
        it('should transform response keys to lowercase', async () => {
            const mockConnectionConfigResponse = {
                success: true,
                data: {
                    DataSource1: {
                        apiId: 'someApiId_dataSource1',
                        connectionName: '01234567-8901-2345-6789-012345678901',
                        runtimeUrl: 'https://contosso.org/1',
                        error: undefined,
                        datasetName: undefined,
                    },
                    DATASOURCe2: {
                        apiId: 'someApiId_dataSource2',
                        connectionName: '09876543-2109-8765-4321-098765432109',
                        runtimeUrl: 'https://contosso.org/2',
                        error: undefined,
                        datasetName: undefined,
                    },
                },
            };
            mockPowerOperationExecutor.execute.mockResolvedValue(mockConnectionConfigResponse);
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            const result = await instance.getAppConnectionConfigsAsync();
            // Verify all keys are converted to lowercase in result
            expect(result.data).toHaveProperty('datasource1');
            expect(result.data).toHaveProperty('datasource2');
            expect(result.data).not.toHaveProperty('DataSource1');
            expect(result.data).not.toHaveProperty('DATASOURCe2');
            // Verify the transformed data structure
            expect(result.data.datasource1).toEqual({
                apiId: 'someApiId_dataSource1',
                connectionName: '01234567-8901-2345-6789-012345678901',
                runtimeUrl: 'https://contosso.org/1',
                error: undefined,
                datasetName: undefined,
            });
            expect(result.data.datasource2).toEqual({
                apiId: 'someApiId_dataSource2',
                connectionName: '09876543-2109-8765-4321-098765432109',
                runtimeUrl: 'https://contosso.org/2',
                error: undefined,
                datasetName: undefined,
            });
        });
        it('should handle empty connection configurations', async () => {
            const mockConnectionConfigResponse = {
                success: true,
                data: {},
            };
            mockPowerOperationExecutor.execute.mockResolvedValue(mockConnectionConfigResponse);
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            const result = await instance.getAppConnectionConfigsAsync();
            // Verify all keys are converted to lowercase in result
            expect(result.success).toBe(true);
            expect(result.data).toEqual({});
        });
    });
    describe('getAppConnectionConfigsAsync - Error Handling', () => {
        it('should throw PowerDataRuntimeError when executor fails', async () => {
            mockPowerOperationExecutor.execute.mockRejectedValue(new Error('Executor failed'));
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            await expect(instance.getAppConnectionConfigsAsync()).rejects.toThrow(PowerDataRuntimeError);
        });
        it('should handle executor returning invalid response format', async () => {
            mockPowerOperationExecutor.execute.mockResolvedValue({}); // Empty object simulating invalid response
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            await expect(instance.getAppConnectionConfigsAsync()).rejects.toThrow(expect.objectContaining({
                code: ErrorCodes.ConnectionConfigFetchFailed,
            }));
        });
        it('should handle executor throwing synchronous errors', async () => {
            mockPowerOperationExecutor.execute.mockImplementation(() => {
                throw new Error('Synchronous error');
            });
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            await expect(instance.getAppConnectionConfigsAsync()).rejects.toThrow(expect.objectContaining({
                code: ErrorCodes.ConnectionConfigFetchFailed,
            }));
        });
    });
    describe('getAppDataSourceConfigsAsync - Happy Path', () => {
        it('should return data source configurations successfully', async () => {
            mockPowerOperationExecutor.execute.mockResolvedValue(mockCdsAppDataSourceConfigs);
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            const result = await instance.getAppDataSourceConfigsAsync();
            expect(mockPowerOperationExecutor.execute).toHaveBeenCalledWith('AppPowerAppsClientPlugin', 'getAppCdsDataSourceConfigsAsync', []);
            expect(result).toEqual(mockCdsAppDataSourceConfigs);
        });
        it('should transform response keys to lowercase', async () => {
            const mockDataSourceConfigResponse = {
                success: true,
                data: {
                    DataSource1: {
                        runtimeUrl: 'https://contosso.org/1',
                        entitySetName: 'someEntitySetName1',
                        logicalName: 'someLogicalName1',
                    },
                    DATASOURCe2: {
                        runtimeUrl: 'https://contosso.org/2',
                        entitySetName: 'someEntitySetName2',
                        logicalName: 'someLogicalName2',
                    },
                },
            };
            mockPowerOperationExecutor.execute.mockResolvedValue(mockDataSourceConfigResponse);
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            const result = await instance.getAppDataSourceConfigsAsync();
            expect(result.data).toHaveProperty('datasource1');
            expect(result.data).toHaveProperty('datasource2');
            expect(result.data).not.toHaveProperty('DataSource1');
            expect(result.data).not.toHaveProperty('DATASOURCe2');
            expect(result.data.datasource1).toEqual({
                runtimeUrl: 'https://contosso.org/1',
                entitySetName: 'someEntitySetName1',
                logicalName: 'someLogicalName1',
            });
            expect(result.data.datasource2).toEqual({
                runtimeUrl: 'https://contosso.org/2',
                entitySetName: 'someEntitySetName2',
                logicalName: 'someLogicalName2',
            });
        });
        it('should handle empty data source configurations', async () => {
            const mockDataSourceConfigResponse = {
                success: true,
                data: {},
            };
            mockPowerOperationExecutor.execute.mockResolvedValue(mockDataSourceConfigResponse);
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            const result = await instance.getAppDataSourceConfigsAsync();
            expect(result.success).toBe(true);
            expect(result.data).toEqual({});
        });
    });
    describe('getAppDataSourceConfigsAsync - Error Handling', () => {
        it('should throw PowerDataRuntimeError when executor fails', async () => {
            mockPowerOperationExecutor.execute.mockRejectedValue(new Error('Executor failed'));
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            await expect(instance.getAppDataSourceConfigsAsync()).rejects.toThrow(PowerDataRuntimeError);
        });
        it('should handle executor returning invalid response format', async () => {
            mockPowerOperationExecutor.execute.mockResolvedValue({}); // Empty object simulating invalid response
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            await expect(instance.getAppDataSourceConfigsAsync()).rejects.toThrow(expect.objectContaining({
                code: ErrorCodes.DataSourceConfigFetchFailed,
            }));
        });
        it('should handle executor throwing synchronous errors', async () => {
            mockPowerOperationExecutor.execute.mockImplementation(() => {
                throw new Error('Synchronous error');
            });
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            await expect(instance.getAppDataSourceConfigsAsync()).rejects.toThrow(expect.objectContaining({
                code: ErrorCodes.DataSourceConfigFetchFailed,
            }));
        });
    });
    describe('Integration Scenarios', () => {
        it('should handle multiple concurrent requests', async () => {
            mockPowerOperationExecutor.execute.mockResolvedValue(mockCdsAppDataSourceConfigs);
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            const promises = [
                instance.getAppDataSourceConfigsAsync(),
                instance.getAppDataSourceConfigsAsync(),
                instance.getAppDataSourceConfigsAsync(),
            ];
            await expect(Promise.all(promises)).resolves.toEqual([
                expect.objectContaining({ success: true }),
                expect.objectContaining({ success: true }),
                expect.objectContaining({ success: true }),
            ]);
        });
        it('should maintain consistent behavior across multiple calls', async () => {
            mockPowerOperationExecutor.execute.mockResolvedValue(mockCdsAppDataSourceConfigs);
            const instance = await RuntimeMetadataClient.createInstanceAsync(mockPowerOperationExecutor);
            const firstCall = await instance.getAppDataSourceConfigsAsync();
            const secondCall = await instance.getAppDataSourceConfigsAsync();
            const thirdCall = await instance.getAppDataSourceConfigsAsync();
            expect(firstCall).toEqual(secondCall);
            expect(secondCall).toEqual(thirdCall);
            expect(firstCall.success).toBe(true);
            expect(secondCall.success).toBe(true);
            expect(thirdCall.success).toBe(true);
            expect(firstCall.data).toEqual(mockCdsAppDataSourceConfigs.data);
            expect(secondCall.data).toEqual(mockCdsAppDataSourceConfigs.data);
            expect(thirdCall.data).toEqual(mockCdsAppDataSourceConfigs.data);
            // Verify no state pollution between calls
            expect(mockPowerOperationExecutor.execute).toHaveBeenCalledTimes(3);
        });
    });
});
/* eslint-enable @typescript-eslint/no-explicit-any */
//# sourceMappingURL=runtimeMetadataClient.test.js.map