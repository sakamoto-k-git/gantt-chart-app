/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { describe, expect, it } from '@jest/globals';
import { createMockDataExecutor } from '../data/executors';
const mockData = {
    users: {
        '1': { id: '1', name: 'John Doe', email: 'john.doe@example.com' },
        '2': { id: '2', name: 'Jane Smith', email: 'jane.smith@example.com' },
        '3': { id: '3', name: 'Alice Johnson', email: 'alice.johnson@example.com' },
    },
};
const mockDataExecutor = createMockDataExecutor(mockData);
describe('MockDataOperationExecutor', () => {
    it('should not throw exceptions on any operation', () => {
        mockDataExecutor.createRecordAsync('users', {
            id: '4',
            name: 'Bob Brown',
            email: 'bob.brown@example.com',
        });
        mockDataExecutor.updateRecordAsync('users', '1', {
            name: 'John Updated',
            email: 'john.updated@example.com',
        });
        mockDataExecutor.deleteRecordAsync('users', '2');
        mockDataExecutor.retrieveRecordAsync('users', '1');
        mockDataExecutor.retrieveMultipleRecordsAsync('users');
        mockDataExecutor.executeAsync({});
    });
    it('should support retrieveRecordAsync for existing record', async () => {
        const result = await mockDataExecutor.retrieveRecordAsync('users', '1');
        expect(result.success).toBe(true);
        expect(result.data).toEqual({ id: '1', name: 'John Doe', email: 'john.doe@example.com' });
    });
    it('should return all records for retrieveMultipleRecordsAsync', async () => {
        const result = await mockDataExecutor.retrieveMultipleRecordsAsync('users');
        expect(result.success).toBe(true);
        expect(result.data?.length).toBe(3);
    });
    it('should fail gracefully for non-existing table', async () => {
        const result = await mockDataExecutor.retrieveRecordAsync('foobar', '1');
        expect(result.success).toBe(false);
        expect(result.error?.message).toEqual(expect.any(String));
    });
    it('should fail gracefully for non-existing record', async () => {
        const result = await mockDataExecutor.retrieveRecordAsync('users', '999');
        expect(result.success).toBe(false);
        expect(result.error?.message).toEqual(expect.any(String));
    });
});
//# sourceMappingURL=mockDataOperationExecutor.spec.js.map