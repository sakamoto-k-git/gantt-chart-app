/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { RuntimeDataClient } from '../internal/data/core/runtimeClient/runtimeDataClient';
import { DataOperationErrorMessages } from '../internal/data/core/error/error';
import { HttpMethod } from '../internal/data/core/common/types';
import { TextDecoder as ImportedTextDecoder, TextEncoder as ImportedTextEncoder } from 'util';
import { suppressConsoleErrorTelemetryLogger } from './helpers/testHelpers';
Object.assign(global, { TextDecoder: ImportedTextDecoder, TextEncoder: ImportedTextEncoder });
class TestableRuntimeDataClient extends RuntimeDataClient {
    executeRequestProxy(config, context) {
        // @ts-expect-error: Accessing private method for testing
        return this._executeRequest(config, context);
    }
}
describe('RuntimeDataClient _executeRequest', () => {
    let client;
    let mockExecutor;
    beforeAll(() => {
        suppressConsoleErrorTelemetryLogger();
    });
    beforeEach(() => {
        mockExecutor = {
            execute: jest.fn(),
        };
        client = new TestableRuntimeDataClient(mockExecutor);
    });
    describe('Response Handling', () => {
        it('should handle empty JSON response gracefully', async () => {
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [{ headers: { 'Content-Type': 'application/json' } }, new TextEncoder().encode('')],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, {});
            expect(result.success).toBe(true);
            expect(result.data).toEqual({});
        });
        it('should handle OData response with value array', async () => {
            const odata = { value: [1, 2, 3] };
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'application/json' } },
                    new TextEncoder().encode(JSON.stringify(odata)),
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, {});
            expect(result.success).toBe(true);
            expect(result.data).toEqual([1, 2, 3]);
        });
        it('should handle image response as base64', async () => {
            const buffer = new ArrayBuffer(4);
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [{ headers: { 'Content-Type': 'image/png' } }, buffer],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, {});
            expect(result.success).toBe(true);
            expect(typeof result.data).toBe('string');
        });
        it('should handle ArrayBuffer as string for other content types', async () => {
            const str = 'test string';
            const buf = new ArrayBuffer(str.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i < str.length; i++) {
                view[i] = str.charCodeAt(i);
            }
            const buffer = buf;
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [{ headers: { 'Content-Type': 'text/plain' } }, buffer],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, {});
            expect(result.success).toBe(true);
            expect(result.data).toBe('test string');
        });
        it('should return error for invalid response', async () => {
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'text/plain' } },
                    12345, // not an ArrayBuffer
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, {});
            expect(result.success).toBe(false);
            expect(result.error).toBeInstanceOf(Error);
            expect(result.error?.message).toBe(DataOperationErrorMessages.InvalidResponse);
        });
    });
    describe('Response Type Handling', () => {
        it('should parse and return array when context.responseInfo.type === "array"', async () => {
            const arr = [10, 20, 30];
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'application/json', status: 200 } },
                    new TextEncoder().encode(JSON.stringify(arr)),
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, { responseInfo: { '200': { type: 'array', format: '' } } });
            expect(result.success).toBe(true);
            expect(Array.isArray(result.data)).toBe(true);
            expect(result.data).toEqual(arr);
        });
        it('should handle empty string as empty array when context.responseInfo.type === "array"', async () => {
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'application/json' }, status: 200 },
                    new TextEncoder().encode('[]'),
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, { responseInfo: { '200': { type: 'array', format: '' } } });
            expect(result.success).toBe(true);
            expect(Array.isArray(result.data)).toBe(true);
            expect(result.data).toEqual([]);
        });
        it('should handle array of objects when context.responseInfo.type === "array"', async () => {
            const arr = [{ id: 1 }, { id: 2 }];
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'application/json' }, status: 200 },
                    new TextEncoder().encode(JSON.stringify(arr)),
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, { responseInfo: { '200': { type: 'array', format: '' } } });
            expect(result.success).toBe(true);
            expect(Array.isArray(result.data)).toBe(true);
            expect(result.data).toEqual(arr);
        });
        it('should parse and return array when context.responseInfo.type === "array" for status 201', async () => {
            const arr = [100, 200];
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'application/json', status: 201 } },
                    new TextEncoder().encode(JSON.stringify(arr)),
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.POST,
                tableName: '',
            }, { responseInfo: { '201': { type: 'array', format: '' } } });
            expect(result.success).toBe(true);
            expect(Array.isArray(result.data)).toBe(true);
            expect(result.data).toEqual(arr);
        });
        it('should parse and return array when context.responseInfo.type === "array" for status 204', async () => {
            const arr = [];
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'application/json', status: 204 } },
                    new TextEncoder().encode(JSON.stringify(arr)),
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.DELETE,
                tableName: '',
            }, { responseInfo: { '204': { type: 'array', format: '' } } });
            expect(result.success).toBe(true);
            expect(Array.isArray(result.data)).toBe(true);
            expect(result.data).toEqual(arr);
        });
        it('should parse and return object when context.responseInfo.type === "object"', async () => {
            const obj = { foo: 'bar', count: 42 };
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'application/json', status: 200 } },
                    new TextEncoder().encode(JSON.stringify(obj)),
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, { responseInfo: { '200': { type: 'object', format: '' } } });
            expect(result.success).toBe(true);
            expect(typeof result.data).toBe('object');
            expect(result.data).toEqual(obj);
        });
        it('should return error if JSON is not an object when context.responseInfo.type === "object"', async () => {
            mockExecutor.execute.mockResolvedValue({
                success: true,
                data: [
                    { headers: { 'Content-Type': 'text/plain', status: 200 } },
                    new TextEncoder().encode('[1,2,3]'),
                ],
            });
            const result = await client.executeRequestProxy({
                apiId: 'api',
                url: '',
                method: HttpMethod.GET,
                tableName: '',
            }, { responseInfo: { '200': { type: 'object', format: '' } } });
            expect(result.success).toBe(false);
            expect(result.error).toBeInstanceOf(Error);
        });
    });
    it('should return error if JSON is null when context.responseInfo.type === "object"', async () => {
        mockExecutor.execute.mockResolvedValue({
            success: true,
            data: [{ headers: { 'Content-Type': 'text/plain', status: 200 } }, new TextEncoder().encode('null')],
        });
        const result = await client.executeRequestProxy({
            apiId: 'api',
            url: '',
            method: HttpMethod.GET,
            tableName: '',
        }, { responseInfo: { '200': { type: 'object', format: '' } } });
        expect(result.success).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error?.message).toBe(DataOperationErrorMessages.InvalidResponse);
    });
    it('should return error if JSON is a string when context.responseInfo.type === "object"', async () => {
        mockExecutor.execute.mockResolvedValue({
            success: true,
            data: [
                { headers: { 'Content-Type': 'text/plain', status: 200 } },
                new TextEncoder().encode('"string"'),
            ],
        });
        const result = await client.executeRequestProxy({
            apiId: 'api',
            url: '',
            method: HttpMethod.GET,
            tableName: '',
        }, { responseInfo: { '200': { type: 'object', format: '' } } });
        expect(result.success).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error?.message).toBe(DataOperationErrorMessages.InvalidResponse);
    });
    it('should return error if JSON is not an array when context.responseInfo.type === "array"', async () => {
        mockExecutor.execute.mockResolvedValue({
            success: true,
            data: [
                { headers: { 'Content-Type': 'text/plain', status: 200 } },
                new TextEncoder().encode('{"foo": "bar"}'),
            ],
        });
        const result = await client.executeRequestProxy({
            apiId: 'api',
            url: '',
            method: HttpMethod.GET,
            tableName: '',
        }, { responseInfo: { '200': { type: 'array', format: '' } } });
        expect(result.success).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error?.message).toBe(DataOperationErrorMessages.InvalidResponse);
    });
    it('should return error if JSON is a string when context.responseInfo.type === "array"', async () => {
        mockExecutor.execute.mockResolvedValue({
            success: true,
            data: [
                { headers: { 'Content-Type': 'text/plain', status: 200 } },
                new TextEncoder().encode('"string"'),
            ],
        });
        const result = await client.executeRequestProxy({
            apiId: 'api',
            url: '',
            method: HttpMethod.GET,
            tableName: '',
        }, { responseInfo: { '200': { type: 'array', format: '' } } });
        expect(result.success).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error?.message).toBe(DataOperationErrorMessages.InvalidResponse);
    });
    it('should return error if JSON is null when context.responseInfo.type === "array"', async () => {
        mockExecutor.execute.mockResolvedValue({
            success: true,
            data: [{ headers: { 'Content-Type': 'text/plain', status: 200 } }, new TextEncoder().encode('null')],
        });
        const result = await client.executeRequestProxy({
            apiId: 'api',
            url: '',
            method: HttpMethod.GET,
            tableName: '',
        }, { responseInfo: { '200': { type: 'array', format: '' } } });
        expect(result.success).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error?.message).toBe(DataOperationErrorMessages.InvalidResponse);
    });
    it('should return error if JSON parsing fails when context.responseInfo exists', async () => {
        mockExecutor.execute.mockResolvedValue({
            success: true,
            data: [
                { headers: { 'Content-Type': 'text/plain', status: 200 } },
                new TextEncoder().encode('invalid json'),
            ],
        });
        const result = await client.executeRequestProxy({
            apiId: 'api',
            url: '',
            method: HttpMethod.GET,
            tableName: '',
        }, { responseInfo: { '200': { type: 'object', format: '' } } });
        expect(result.success).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error?.message).toBe(DataOperationErrorMessages.InvalidResponse);
    });
});
//# sourceMappingURL=runtimeDataClient.spec.js.map