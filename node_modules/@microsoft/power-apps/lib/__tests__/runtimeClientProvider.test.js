/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { afterEach, beforeEach, describe, it, jest } from '@jest/globals';
import { PowerDataRuntimeError } from '../internal/data/core/error/error';
import { RuntimeClientProvider } from '../internal/data/core/runtimeClient/runtimeClientProvider';
import { RuntimeDataClient } from '../internal/data/core/runtimeClient/runtimeDataClient';
import { RuntimeMetadataClient } from '../internal/data/core/runtimeClient/runtimeMetadataClient';
import { mockSilentLogger } from './mocks/mockLog';
import { silenceConsole } from './mocks/silenceConsole';
// Mock the runtime client modules to control their behavior in tests
jest.mock('../internal/data/core/runtimeClient/runtimeDataClient');
jest.mock('../internal/data/core/runtimeClient/runtimeMetadataClient');
// Mock the telemetry log module to avoid actual logging during tests
jest.mock('../internal/data/core/telemetry/log', () => mockSilentLogger);
describe('RuntimeClientProvider', () => {
    // Test fixtures and mocks
    let runtimeClientProvider;
    let mockPowerOperationExecutor;
    let mockDataClient;
    let mockMetadataClient;
    // Spies for static factory methods
    let createDataClientSpy;
    let createMetadataClientSpy;
    // Console silencing setup - silence all console output for this test file
    let consoleMocks;
    // Setup before each test
    beforeEach(() => {
        // Create mocked power operation executor
        mockPowerOperationExecutor = {
            execute: jest.fn(),
        };
        // Create mocked runtime clients
        mockDataClient = {
            createDataAsync: jest.fn(),
            updateDataAsync: jest.fn(),
            deleteDataAsync: jest.fn(),
            retrieveDataAsync: jest.fn(),
        };
        mockMetadataClient = {
            getAppConnectionConfigsAsync: jest.fn(),
            getAppDataSourceConfigsAsync: jest.fn(),
        };
        // Setup spies for static factory methods
        createDataClientSpy = jest
            .spyOn(RuntimeDataClient, 'createInstanceAsync')
            .mockResolvedValue(mockDataClient);
        createMetadataClientSpy = jest
            .spyOn(RuntimeMetadataClient, 'createInstanceAsync')
            .mockResolvedValue(mockMetadataClient);
        // Create fresh instance for each test
        runtimeClientProvider = new RuntimeClientProvider(mockPowerOperationExecutor);
        consoleMocks = silenceConsole();
    });
    // Cleanup after each test
    afterEach(() => {
        jest.clearAllMocks();
        createDataClientSpy.mockRestore();
        createMetadataClientSpy.mockRestore();
        consoleMocks.restore();
    });
    describe('Constructor', () => {
        it('should initialize with provided power operation executor', async () => {
            runtimeClientProvider = new RuntimeClientProvider(mockPowerOperationExecutor);
            // Verify clients are not initialized until requested
            expect(createDataClientSpy).toHaveBeenCalledTimes(0);
            expect(createMetadataClientSpy).toHaveBeenCalledTimes(0);
        });
    });
    describe('getDataClientAsync - Happy Path', () => {
        it('should initialize data client only when getDataClientAsync is called the first time', async () => {
            expect(createDataClientSpy).toHaveBeenCalledTimes(0);
            await runtimeClientProvider.getDataClientAsync();
            expect(createDataClientSpy).toHaveBeenCalledTimes(1);
        });
        it('should return cached data client on subsequent calls', async () => {
            const client1 = await runtimeClientProvider.getDataClientAsync();
            const client2 = await runtimeClientProvider.getDataClientAsync();
            expect(client1).toBe(client2);
        });
    });
    describe('getDataClientAsync - Error Handling', () => {
        it('should throw DataClientInitFailed when createInstanceAsync fails with error', async () => {
            createDataClientSpy.mockRejectedValue(new Error('Initialization failed'));
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerDataClient: Initialization failed',
            }));
        });
        it('should throw when createInstanceAsync throwing synchronous errors', async () => {
            // TODO: Test synchronous error handling
            createDataClientSpy.mockImplementation(() => {
                throw new Error('Synchronous error');
            });
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerDataClient: Synchronous error',
            }));
        });
        it('should throw DataClientNotInitialized when createInstanceAsync returns undefined', async () => {
            createDataClientSpy.mockResolvedValue(undefined);
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerDataClient: PowerDataClient is not initialized',
            }));
        });
        it('should throw DataClientNotInitialized when createInstanceAsync returns null', async () => {
            createDataClientSpy.mockResolvedValue(null);
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerDataClient: PowerDataClient is not initialized',
            }));
        });
        it('should handle async rejections and convert to PowerDataRuntimeError', async () => {
            createDataClientSpy.mockImplementation(() => {
                return Promise.reject(new Error('Async error'));
            });
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getDataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerDataClient: Async error',
            }));
        });
    });
    describe('getMetadataClientAsync - Happy Path', () => {
        it('should initialize metadata client only when getMetadataClientAsync is called the first time', async () => {
            // TODO: Test that initialization doesn't happen until requested
            expect(createMetadataClientSpy).toHaveBeenCalledTimes(0);
            await runtimeClientProvider.getMetadataClientAsync();
            expect(createMetadataClientSpy).toHaveBeenCalledTimes(1);
            expect(createMetadataClientSpy).toHaveBeenCalledWith(mockPowerOperationExecutor);
        });
        it('should return cached metadata client on subsequent calls', async () => {
            // TODO: Test lazy initialization caching behavior
            const client1 = await runtimeClientProvider.getMetadataClientAsync();
            const client2 = await runtimeClientProvider.getMetadataClientAsync();
            expect(client1).toBe(client2);
        });
    });
    describe('getMetadataClientAsync - Error Handling', () => {
        it('should throw MetadataClientInitFailed when createInstanceAsync fails with error', async () => {
            createMetadataClientSpy.mockRejectedValue(new Error('Initialization failed'));
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerMetadataClient: Initialization failed',
            }));
        });
        it('should throw when createInstanceAsync throwing synchronous errors', async () => {
            // TODO: Test synchronous error handling
            createMetadataClientSpy.mockImplementation(() => {
                throw new Error('Synchronous error');
            });
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerMetadataClient: Synchronous error',
            }));
        });
        it('should throw MetadataClientNotInitialized when createInstanceAsync returns undefined', async () => {
            createMetadataClientSpy.mockResolvedValue(undefined);
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerMetadataClient: PowerMetadataClient is not initialized',
            }));
        });
        it('should throw MetadataClientNotInitialized when createInstanceAsync returns null', async () => {
            createMetadataClientSpy.mockResolvedValue(null);
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerMetadataClient: PowerMetadataClient is not initialized',
            }));
        });
        it('should handle async rejections and convert to PowerDataRuntimeError', async () => {
            createMetadataClientSpy.mockImplementation(() => {
                return Promise.reject(new Error('Async error'));
            });
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(PowerDataRuntimeError);
            await expect(runtimeClientProvider.getMetadataClientAsync()).rejects.toThrow(expect.objectContaining({
                name: 'PowerDataRuntimeError',
                message: 'Failed to initialize PowerMetadataClient: Async error',
            }));
        });
    });
    describe('reset() Method', () => {
        it('should reset both clients to undefined', async () => {
            // Initialize clients first
            await runtimeClientProvider.getDataClientAsync();
            await runtimeClientProvider.getMetadataClientAsync();
            // Verify clients were created
            expect(createDataClientSpy).toHaveBeenCalledTimes(1);
            expect(createMetadataClientSpy).toHaveBeenCalledTimes(1);
            // Reset the clients
            runtimeClientProvider.reset();
            // Verify that calling the getters again will create new instances
            await runtimeClientProvider.getDataClientAsync();
            await runtimeClientProvider.getMetadataClientAsync();
            expect(createDataClientSpy).toHaveBeenCalledTimes(2);
            expect(createMetadataClientSpy).toHaveBeenCalledTimes(2);
        });
        it('should allow re-initialization after reset', async () => {
            // Initialize clients first
            await runtimeClientProvider.getDataClientAsync();
            await runtimeClientProvider.getMetadataClientAsync();
            // Reset the clients
            runtimeClientProvider.reset();
            // Re-initialize clients
            const newDataClient = await runtimeClientProvider.getDataClientAsync();
            const newMetadataClient = await runtimeClientProvider.getMetadataClientAsync();
            // Verify new instances are created
            expect(newDataClient).toBeDefined();
            expect(newMetadataClient).toBeDefined();
            expect(createDataClientSpy).toHaveBeenCalledTimes(2);
            expect(createMetadataClientSpy).toHaveBeenCalledTimes(2);
        });
        it('should reset even if clients were never initialized', () => {
            // Verify clients are not initialized initially
            expect(createDataClientSpy).toHaveBeenCalledTimes(0);
            expect(createMetadataClientSpy).toHaveBeenCalledTimes(0);
            // Reset the clients without prior initialization
            runtimeClientProvider.reset();
            // Verify reset doesn't cause any issues
            expect(createDataClientSpy).toHaveBeenCalledTimes(0);
            expect(createMetadataClientSpy).toHaveBeenCalledTimes(0);
        });
    });
    describe('Concurrent Access Patterns', () => {
        it('should handle concurrent calls to getDataClientAsync correctly', async () => {
            // TODO: Test thread-safety and race conditions
            const promises = Array.from({ length: 10 }, () => runtimeClientProvider.getDataClientAsync());
            const results = await Promise.all(promises);
            expect(results.every((client) => client === results[0])).toBe(true);
        });
        it('should handle concurrent calls to getMetadataClientAsync correctly', async () => {
            // TODO: Test thread-safety and race conditions
            const promises = Array.from({ length: 10 }, () => runtimeClientProvider.getMetadataClientAsync());
            const results = await Promise.all(promises);
            expect(results.every((client) => client === results[0])).toBe(true);
        });
    });
});
//# sourceMappingURL=runtimeClientProvider.test.js.map