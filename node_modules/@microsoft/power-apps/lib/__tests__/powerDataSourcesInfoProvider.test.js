/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { afterEach, beforeEach, describe, it, jest } from '@jest/globals';
import { ErrorCodes, PowerDataRuntimeError } from '../internal/data/core/error/error';
import PowerDataSourcesInfoProvider from '../internal/data/core/runtime/powerDataSourcesInfoProvider';
import { mockSilentLogger } from './mocks/mockLog';
import { silenceConsole } from './mocks/silenceConsole';
/* eslint-disable @typescript-eslint/no-explicit-any */
// Mock the telemetry log module to avoid actual logging during tests
jest.mock('../internal/data/core/telemetry/log', () => mockSilentLogger);
describe('PowerDataSourcesInfoProvider', () => {
    // Console silencing setup - silence all console output for this test file
    // In this test we expect PowerDataRuntimeError to be thrown, but Log has not been initialized yet
    // so we silence console output to avoid cluttering test results
    let consoleMocks;
    beforeEach(() => {
        // Reset singleton instance to ensure test isolation
        PowerDataSourcesInfoProvider.instance = null;
        // Silence console output for cleaner test runs
        consoleMocks = silenceConsole();
    });
    afterEach(() => {
        jest.clearAllMocks();
        // Reset singleton instance for clean state
        PowerDataSourcesInfoProvider.instance = null;
        // Restore console methods
        consoleMocks.restore();
    });
    // Test fixtures and mocks
    const mockDataSourcesInfo = {
        abc: {
            tableId: '123',
            version: '1.0.0',
            primaryKey: 'testKey',
            dataSourceType: 'testType',
            apis: {
                createRecord: {
                    method: 'POST',
                    path: '/api/create',
                    parameters: [
                        {
                            name: 'record',
                            type: 'object',
                            required: true,
                            in: 'body',
                        },
                    ],
                },
            },
        },
    };
    const secondMockDataSourcesInfo = {
        def: {
            tableId: '456',
            version: '2.0.0',
            primaryKey: 'testKey2',
            dataSourceType: 'testType2',
            apis: {
                createRecord: {
                    method: 'POST',
                    path: '/api/update',
                    parameters: [
                        {
                            name: 'record',
                            type: 'object',
                            required: true,
                            in: 'body',
                        },
                    ],
                },
            },
        },
    };
    describe('getInstance - Singleton Pattern', () => {
        it('should create instance when called first time with dataSourcesInfo', async () => {
            const instance = PowerDataSourcesInfoProvider.getInstance(mockDataSourcesInfo);
            expect(instance).toBeInstanceOf(PowerDataSourcesInfoProvider);
            await expect(instance.getDataSourcesInfo()).resolves.toEqual(mockDataSourcesInfo);
        });
        it('should return same instance on subsequent calls without dataSourcesInfo', () => {
            const instance = PowerDataSourcesInfoProvider.getInstance(mockDataSourcesInfo);
            const sameInstance = PowerDataSourcesInfoProvider.getInstance();
            expect(sameInstance).toBe(instance);
        });
        it('should return same instance on subsequent calls with different dataSourcesInfo', async () => {
            const instance = PowerDataSourcesInfoProvider.getInstance(mockDataSourcesInfo);
            const instance2 = PowerDataSourcesInfoProvider.getInstance(secondMockDataSourcesInfo);
            expect(instance2).toBe(instance);
            await expect(instance.getDataSourcesInfo()).resolves.toEqual(mockDataSourcesInfo);
            await expect(instance2.getDataSourcesInfo()).resolves.toEqual(mockDataSourcesInfo);
        });
    });
    describe('getInstance - Error Handling', () => {
        it('should throw PowerDataRuntimeError when called without dataSourcesInfo and no instance exists', () => {
            expect(() => PowerDataSourcesInfoProvider.getInstance()).toThrow(PowerDataRuntimeError);
            expect(() => PowerDataSourcesInfoProvider.getInstance()).toThrowError(expect.objectContaining({
                code: ErrorCodes.DataSourcesInfoNotFound,
            }));
        });
        it('should throw PowerDataRuntimeError when called with undefined dataSourcesInfo and no instance exists', () => {
            expect(() => PowerDataSourcesInfoProvider.getInstance(undefined)).toThrow(PowerDataRuntimeError);
            expect(() => PowerDataSourcesInfoProvider.getInstance(undefined)).toThrowError(expect.objectContaining({
                code: ErrorCodes.DataSourcesInfoNotFound,
            }));
        });
        it('should throw PowerDataRuntimeError when called with null dataSourcesInfo and no instance exists', () => {
            expect(() => PowerDataSourcesInfoProvider.getInstance(null)).toThrow(PowerDataRuntimeError);
            expect(() => PowerDataSourcesInfoProvider.getInstance(null)).toThrowError(expect.objectContaining({
                code: ErrorCodes.DataSourcesInfoNotFound,
            }));
        });
    });
    describe('getDataSourcesInfo - Happy Path', () => {
        it('should return the data sources info provided during initialization', async () => {
            const instance = PowerDataSourcesInfoProvider.getInstance(mockDataSourcesInfo);
            expect(await instance.getDataSourcesInfo()).toEqual(mockDataSourcesInfo);
        });
        it('should return consistent data sources info across multiple calls', async () => {
            const instance = PowerDataSourcesInfoProvider.getInstance(mockDataSourcesInfo);
            const firstCall = await instance.getDataSourcesInfo();
            const secondCall = await instance.getDataSourcesInfo();
            const thirdCall = await instance.getDataSourcesInfo();
            expect(firstCall).toBe(secondCall);
            expect(secondCall).toBe(thirdCall);
        });
    });
    describe('Singleton State Management', () => {
        it('should maintain singleton instance across different test scenarios', () => {
            const instance1 = PowerDataSourcesInfoProvider.getInstance(mockDataSourcesInfo);
            const instance2 = PowerDataSourcesInfoProvider.getInstance();
            expect(instance2).toBe(instance1);
        });
        it('should preserve data sources info throughout instance lifecycle', async () => {
            const instance = PowerDataSourcesInfoProvider.getInstance(mockDataSourcesInfo);
            const originalData = await instance.getDataSourcesInfo();
            await instance.getDataSourcesInfo();
            await instance.getDataSourcesInfo();
            const finalData = await instance.getDataSourcesInfo();
            expect(finalData).toBe(originalData);
            expect(finalData).toEqual(mockDataSourcesInfo);
        });
        it('should handle concurrent getDataSourcesInfo calls correctly', async () => {
            const instance = PowerDataSourcesInfoProvider.getInstance(mockDataSourcesInfo);
            const promises = Array.from({ length: 10 }, () => instance.getDataSourcesInfo());
            const results = await Promise.all(promises);
            expect(results.every((result) => result === results[0])).toBe(true);
            expect(results[0]).toEqual(mockDataSourcesInfo);
        });
    });
});
/* eslint-enable @typescript-eslint/no-explicit-any */
//# sourceMappingURL=powerDataSourcesInfoProvider.test.js.map