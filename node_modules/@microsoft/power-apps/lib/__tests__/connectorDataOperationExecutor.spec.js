/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { ConnectorDataOperationExecutor } from '../internal/data/core/data/executors/connectorDataOperationExecutor';
import { DataOperationErrorMessages, ErrorCodes, ErrorMessages } from '../internal/data/core/error/error';
import { getMockClientProvider, getMockConnectionsService, getMockDataClient, getMockMetadataClient, suppressConsoleErrorTelemetryLogger, } from './helpers/testHelpers';
import { expect } from '@jest/globals';
describe('ConnectorDataOperationExecutor', () => {
    let clientProvider;
    let connectionsService;
    let dataClient;
    let metadataClient;
    let instance;
    const tableName = 'TestTable';
    const connectionReference = {
        apiId: 'apiId',
        runtimeUrl: 'https://runtime',
        connectionName: 'connName',
        datasetName: 'ds',
        tableId: 'tid',
        version: 'v1',
    };
    const connectionReferences = { [tableName]: connectionReference };
    const dataSourceInfo = {
        tableId: 'tid',
        version: 'v1',
        apis: {
            op: {
                parameters: [
                    {
                        name: 'userId',
                        in: 'header',
                        required: true,
                        type: 'string',
                    },
                    {
                        name: 'optionalHeader',
                        in: 'header',
                        required: false,
                        type: 'number',
                    },
                ],
                path: '/op',
            },
        },
    };
    beforeAll(() => {
        suppressConsoleErrorTelemetryLogger();
    });
    beforeEach(() => {
        dataClient = getMockDataClient();
        metadataClient = getMockMetadataClient(connectionReferences);
        clientProvider = getMockClientProvider(dataClient, metadataClient);
        connectionsService = getMockConnectionsService(dataSourceInfo);
        instance = new TestableConnectorDataOperation(clientProvider, connectionsService);
        // Reset private cache
        instance._connectionReferences = undefined;
        instance._databaseReferences = undefined;
    });
    describe('CRUD Operations', () => {
        it('should create a record', async () => {
            const data = { foo: 'bar' };
            const result = await instance.createRecordAsync(tableName, data);
            expect(result.success).toBe(true);
            expect(dataClient.createDataAsync).toHaveBeenCalledWith(expect.stringContaining('https://runtime'), connectionReference.apiId, tableName, data, expect.objectContaining({ operationName: 'connectorDataOperation.createRecordAsync' }));
        });
        it('should update a record', async () => {
            const data = { foo: 'baz' };
            const id = '1';
            const result = await instance.updateRecordAsync(tableName, id, data);
            expect(result.success).toBe(true);
            expect(dataClient.updateDataAsync).toHaveBeenCalledWith(expect.stringContaining('https://runtime'), connectionReference.apiId, tableName, data, expect.objectContaining({ operationName: 'connectorDataOperation.updateRecordAsync' }));
        });
        it('should delete a record', async () => {
            const id = '1';
            const result = await instance.deleteRecordAsync(tableName, id);
            expect(result.success).toBe(true);
            expect(dataClient.deleteDataAsync).toHaveBeenCalledWith(expect.stringContaining('https://runtime'), connectionReference.apiId, tableName, expect.objectContaining({ operationName: 'connectorDataOperation.deleteRecordAsync' }));
        });
        it('should retrieve a record', async () => {
            const id = '1';
            const options = {};
            const result = await instance.retrieveRecordAsync(tableName, id, options);
            expect(result.success).toBe(true);
            expect(dataClient.retrieveDataAsync).toHaveBeenCalledWith(expect.stringContaining('https://runtime'), connectionReference.apiId, tableName, 'GET', undefined, expect.objectContaining({ operationName: 'connectorDataOperation.retrieveRecordAsync' }));
        });
    });
    describe('Parameter Mapping', () => {
        it('should populate header parameters from object type input parameters', async () => {
            const parameters = { userId: '123', optionalHeader: 456 };
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName: 'op',
                    parameters,
                },
            });
            expect(result.success).toBe(true);
            expect(dataClient.retrieveDataAsync).toHaveBeenCalledWith('https://runtime/op', 'apiId', 'TestTable', 'GET', { userId: '123', optionalHeader: 456 }, undefined, { isExecuteAsync: true, operationName: 'connectorDataOperation.op' });
        });
        it('should handle missing optional header parameters from object type input parameters', async () => {
            const parameters = { userId: '123' };
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName: 'op',
                    parameters,
                },
            });
            expect(result.success).toBe(true);
            expect(dataClient.retrieveDataAsync).toHaveBeenCalledWith('https://runtime/op', 'apiId', 'TestTable', 'GET', { userId: '123' }, undefined, { isExecuteAsync: true, operationName: 'connectorDataOperation.op' });
        });
        it('should handle header parameters from array type input parameters', async () => {
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName: 'op',
                    parameters: ['123', 456],
                },
            });
            expect(result.success).toBe(true);
            expect(dataClient.retrieveDataAsync).toHaveBeenCalledWith('https://runtime/op', 'apiId', 'TestTable', 'GET', { userId: '123', optionalHeader: 456 }, undefined, { isExecuteAsync: true, operationName: 'connectorDataOperation.op' });
        });
        it('should handle missing connection reference', async () => {
            instance._connectionReferences = {};
            const result = await instance.createRecordAsync('UnknownTable', { foo: 'bar' });
            expect(result.success).toBe(false);
            expect(result.error).toBeInstanceOf(Error);
            if (result.error) {
                expect(result.error.message).toContain(ErrorMessages[ErrorCodes.ConnectionReferenceNotFound]);
            }
        });
    });
    describe('Error Handling', () => {
        it('should throw if constructed with missing clientProvider', () => {
            expect(() => new ConnectorDataOperationExecutor(undefined, connectionsService)).toThrow(ErrorMessages[ErrorCodes.ClientProviderNotAvailable]);
        });
        it('should throw if constructed with missing connectionsService', () => {
            expect(() => new ConnectorDataOperationExecutor(clientProvider, undefined)).toThrow(ErrorMessages[ErrorCodes.DataSourceServiceNotAvailable]);
        });
        it('should handle error from data client', async () => {
            dataClient.createDataAsync.mockRejectedValue(new Error('fail'));
            const result = await instance.createRecordAsync(tableName, { foo: 'bar' });
            expect(result.success).toBe(false);
            expect(result.error).toBeInstanceOf(Error);
            if (result.error) {
                expect(result.error.message).toContain(DataOperationErrorMessages.CreateFailed);
            }
        });
    });
    describe('_buildOperationBodyParam', () => {
        it('should map body parameters correctly, including normalized names and special "body" param', async () => {
            // Arrange
            const testInstance = new TestableConnectorDataOperation(clientProvider, connectionsService);
            const testOperationName = 'customOp';
            const testTableName = 'TestTable';
            const apiParams = [
                { name: 'connectionId', in: 'path', required: true },
                { name: 'body', in: 'body', required: true },
                { name: 'foo-bar', in: 'body', required: false },
                { name: 'baz_param', in: 'body', required: false },
            ];
            const testDataSourceInfo = {
                tableId: 'tid',
                version: 'v1',
                apis: {
                    [testOperationName]: { parameters: apiParams },
                },
            };
            connectionsService.getDataSource.mockResolvedValue(testDataSourceInfo);
            // The rawParams object uses both hyphens and underscores
            const parameters = {
                connectionId: '123',
                body: { a: 1, b: 2 },
                foo_bar: 42,
                'baz-param': 'hello',
            };
            const operation = {
                connectorOperation: {
                    tableName: testTableName,
                    operationName: testOperationName,
                    parameters,
                },
            };
            // Act
            const result = await testInstance.buildOperationBodyParam(operation, testTableName);
            // Assert
            expect(JSON.parse(result)).toEqual({
                a: 1,
                b: 2,
            });
        });
    });
    describe('_getNormalizedParamValue', () => {
        let testInstance;
        beforeEach(() => {
            testInstance = new TestableConnectorDataOperation(clientProvider, connectionsService);
        });
        function callGetNormalizedParamValue(obj, paramName) {
            // @ts-expect-error: Accessing private method for testing
            return testInstance._getNormalizedParamValue(obj, paramName);
        }
        it('returns value for exact match', () => {
            const obj = { foo_bar: 123 };
            expect(callGetNormalizedParamValue(obj, 'foo_bar')).toBe(123);
        });
        it('returns value for hyphen/underscore normalization', () => {
            const obj = { 'foo-bar': 456 };
            expect(callGetNormalizedParamValue(obj, 'foo_bar')).toBe(456);
            expect(callGetNormalizedParamValue(obj, 'foo-bar')).toBe(456);
        });
        it('returns undefined if no match', () => {
            const obj = { bar: 789 };
            expect(callGetNormalizedParamValue(obj, 'baz')).toBeUndefined();
        });
        it('returns value for paramName with hyphens when object uses underscores', () => {
            const obj = { foo_bar: 321 };
            expect(callGetNormalizedParamValue(obj, 'foo-bar')).toBe(321);
        });
        it('returns value for case insensitive match with underscores', () => {
            const obj = { FOO_BAR: 100 };
            expect(callGetNormalizedParamValue(obj, 'foo_bar')).toBe(100);
            expect(callGetNormalizedParamValue(obj, 'Foo_Bar')).toBe(100);
            expect(callGetNormalizedParamValue(obj, 'FOO_BAR')).toBe(100);
        });
        it('returns value for case insensitive match with hyphens', () => {
            const obj = { 'FOO-BAR': 200 };
            expect(callGetNormalizedParamValue(obj, 'foo-bar')).toBe(200);
            expect(callGetNormalizedParamValue(obj, 'Foo-Bar')).toBe(200);
            expect(callGetNormalizedParamValue(obj, 'FOO-BAR')).toBe(200);
        });
        it('returns value for case insensitive match with mixed hyphen/underscore normalization', () => {
            const obj = { 'User-ID': 300 };
            expect(callGetNormalizedParamValue(obj, 'user_id')).toBe(300);
            expect(callGetNormalizedParamValue(obj, 'USER_ID')).toBe(300);
            expect(callGetNormalizedParamValue(obj, 'User_ID')).toBe(300);
        });
        it('returns value for case insensitive match when searching for mixed case param in lowercase object', () => {
            const obj = { user_id: 400 };
            expect(callGetNormalizedParamValue(obj, 'User-ID')).toBe(400);
            expect(callGetNormalizedParamValue(obj, 'USER-ID')).toBe(400);
            expect(callGetNormalizedParamValue(obj, 'User_ID')).toBe(400);
        });
    });
    // Helper subclass to expose protected/private methods for testing
    class TestableConnectorDataOperation extends ConnectorDataOperationExecutor {
        buildStandardOperationUrl(operation, config, operationName, path) {
            // @ts-expect-error: Accessing private method for testing
            return this._buildStandardOperationUrl(operation, config, operationName, path);
        }
        buildOperationBodyParam(operation, testTableName) {
            // @ts-expect-error: Accessing private method for testing
            return this._buildOperationBodyParam(operation, testTableName);
        }
    }
    describe('_buildStandardOperationUrl parameter mapping', () => {
        let testInstance;
        const testConfig = {
            tableName: 'TestTable',
            apiId: 'apiId',
            runtimeUrl: 'https://runtime',
            connectionName: 'connName',
            datasetName: 'ds',
            tableId: 'tid',
            version: 'v1',
        };
        const testOperationName = 'op';
        const testPath = '/op';
        beforeEach(() => {
            testInstance = new TestableConnectorDataOperation(clientProvider, connectionsService);
            connectionsService.getDataSource.mockResolvedValue({
                tableId: 'tid',
                version: 'v1',
                apis: {
                    [testOperationName]: {
                        parameters: [
                            { name: 'connectionId', in: 'path', required: true },
                            { name: 'dataset', in: 'path', required: true },
                            { name: 'tableName', in: 'path', required: true },
                            { name: 'foo-bar', in: 'query', required: false },
                            { name: 'baz_param', in: 'query', required: false },
                        ],
                        path: testPath,
                    },
                },
            });
        });
        it('maps string operationParams', async () => {
            const operation = { connectorOperation: { parameters: 'abc', operationName: testOperationName } };
            const url = await testInstance.buildStandardOperationUrl(operation, testConfig, testOperationName, testPath);
            expect(url).toMatchInlineSnapshot(`"https://runtime/op?foo-bar=abc"`);
        });
        it('maps object operationParams with normalization', async () => {
            const operation = {
                connectorOperation: {
                    parameters: { foo_bar: 1, 'baz-param': 2 },
                    operationName: testOperationName,
                },
            };
            const url = await testInstance.buildStandardOperationUrl(operation, testConfig, testOperationName, testPath);
            expect(url).toContain('foo-bar=1');
            expect(url).toContain('baz_param=2');
        });
        it('always maps connectionId, dataset, and tableName', async () => {
            const pathTemplate = '/connections/{connectionId}/datasets/{dataset}/tables/{tableName}/items';
            const operation = {
                connectorOperation: {
                    parameters: {},
                    operationName: testOperationName,
                },
            };
            const url = await testInstance.buildStandardOperationUrl(operation, testConfig, testOperationName, pathTemplate);
            expect(url).toMatchInlineSnapshot(`"https://runtime/connections/connName/datasets/ds/tables/TestTable/items"`);
        });
    });
    describe('Connector header parameter handling', () => {
        const operationName = 'testOp';
        const baseApi = {
            path: '/testOp',
            parameters: [
                { name: 'param1', in: 'header', required: true, type: 'string' },
                { name: 'param2', in: 'header', required: false, type: 'number' },
                { name: 'param3', in: 'header', required: false, type: 'boolean' },
                { name: 'param4', in: 'header', required: false, type: 'object' },
                { name: 'param5', in: 'header', required: false, type: 'array' },
            ],
        };
        beforeEach(() => {
            // Add the test operation to the dataSourceInfo mock
            dataSourceInfo.apis[operationName] = baseApi;
        });
        it('should succeed when only header parameters are provided (no input)', async () => {
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName,
                },
            });
            expect(result.success).toBe(true);
            expect(dataClient.retrieveDataAsync).toHaveBeenCalledWith('https://runtime/testOp', 'apiId', 'TestTable', 'GET', undefined, undefined, {
                isExecuteAsync: true,
                operationName: `connectorDataOperation.${operationName}`,
            });
        });
        it('should succeed with required header parameter (string)', async () => {
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName,
                    parameters: { param1: 'foo' },
                },
            });
            expect(result.success).toBe(true);
            expect(dataClient.retrieveDataAsync).toHaveBeenCalledWith('https://runtime/testOp', 'apiId', 'TestTable', 'GET', { param1: 'foo' }, undefined, {
                isExecuteAsync: true,
                operationName: `connectorDataOperation.${operationName}`,
            });
        });
        it('should succeed with multiple header parameters (string, number, boolean)', async () => {
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName,
                    parameters: { param1: 'foo', param2: 42, param3: true },
                },
            });
            expect(result.success).toBe(true);
            expect(dataClient.retrieveDataAsync).toHaveBeenCalledWith('https://runtime/testOp', 'apiId', 'TestTable', 'GET', { param1: 'foo', param2: 42, param3: true }, undefined, {
                isExecuteAsync: true,
                operationName: `connectorDataOperation.${operationName}`,
            });
        });
        it('should succeed with object and array header parameters', async () => {
            const obj = { a: 1 };
            const arr = [1, 2, 3];
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName,
                    parameters: { param1: 'foo', param4: obj, param5: arr },
                },
            });
            expect(result.success).toBe(true);
            // Get the actual call arguments
            const callArgs = dataClient.retrieveDataAsync.mock.calls[0];
            const headers = callArgs[4];
            expect(headers.param1).toBe('foo');
            expect(typeof headers.param4).toBe('object');
            expect(headers.param4).toEqual(obj);
            expect(Array.isArray(headers.param5)).toBe(true);
            expect(headers.param5).toEqual(arr);
        });
        [
            [
                'string',
                { param1: 'foo' },
                (headers) => expect(typeof headers.param1).toBe('string'),
            ],
            [
                'number',
                { param2: 123 },
                (headers) => expect(typeof headers.param2).toBe('number'),
            ],
            [
                'boolean',
                { param3: true },
                (headers) => expect(typeof headers.param3).toBe('boolean'),
            ],
            [
                'object',
                { param4: { x: 1 } },
                (headers) => expect(typeof headers.param4).toBe('object'),
            ],
            [
                'array',
                { param5: [1, 2, 3] },
                (headers) => expect(Array.isArray(headers.param5)).toBe(true),
            ],
        ].forEach(([type, params, typeCheck]) => {
            it(`should succeed for header parameter of type: ${type}`, async () => {
                const result = await instance.executeAsync({
                    connectorOperation: {
                        tableName,
                        operationName,
                        parameters: params,
                    },
                });
                expect(result.success).toBe(true);
                const callArgs = dataClient.retrieveDataAsync.mock.calls[0];
                const headers = callArgs[4];
                Object.entries(params).forEach(([key, value]) => {
                    expect(headers[key]).toEqual(value);
                });
                typeCheck(headers);
            });
        });
    });
    describe('executeAsync additional scenarios', () => {
        const operationName = 'outputTestOp';
        // Use Record<string, unknown> for apis
        const apis = dataSourceInfo.apis;
        const outputApi = {
            path: '/outputTestOp',
            parameters: [
                { name: 'paramA', in: 'header', required: true, type: 'string' },
                { name: 'paramB', in: 'header', required: false, type: 'number' },
            ],
            responses: {
                200: {
                    description: 'Success',
                    schema: {
                        type: 'object',
                        properties: {
                            result: { type: 'string' },
                            value: { type: 'number' },
                        },
                    },
                },
            },
        };
        beforeEach(() => {
            dataClient.retrieveDataAsync.mockResolvedValue({ success: true, data: { result: 'ok', value: 123 } });
            apis[operationName] = outputApi;
        });
        it('should return output with correct structure and types', async () => {
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName,
                    parameters: { paramA: 'foo', paramB: 42 },
                },
            });
            expect(result.success).toBe(true);
            expect(result.data).toEqual({ result: 'ok', value: 123 });
            expect(typeof result.data.result).toBe('string');
            expect(typeof result.data.value).toBe('number');
        });
        it('should work with parameter order (array input)', async () => {
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName,
                    parameters: ['foo', 42],
                },
            });
            expect(result.success).toBe(true);
            expect(dataClient.retrieveDataAsync).toHaveBeenCalledWith('https://runtime/outputTestOp', 'apiId', 'TestTable', 'GET', { paramA: 'foo', paramB: 42 }, undefined, {
                isExecuteAsync: true,
                operationName: `connectorDataOperation.${operationName}`,
            });
        });
        it('should handle no output (empty response)', async () => {
            dataClient.retrieveDataAsync.mockResolvedValue({ success: true, data: undefined });
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName,
                    parameters: { paramA: 'foo' },
                },
            });
            expect(result.success).toBe(true);
            expect(result.data).toBeUndefined();
        });
        it('should handle multiple output properties', async () => {
            dataClient.retrieveDataAsync.mockResolvedValue({
                success: true,
                data: { result: 'done', value: 999, extra: true },
            });
            const result = await instance.executeAsync({
                connectorOperation: {
                    tableName,
                    operationName,
                    parameters: { paramA: 'bar', paramB: 7 },
                },
            });
            expect(result.success).toBe(true);
            expect(result.data).toEqual({ result: 'done', value: 999, extra: true });
            expect(typeof result.data.extra).toBe('boolean');
        });
    });
});
//# sourceMappingURL=connectorDataOperationExecutor.spec.js.map