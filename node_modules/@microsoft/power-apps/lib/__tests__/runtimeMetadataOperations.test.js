/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { RuntimeMetadataOperations } from '../internal/data/core/metadata/runtimeMetadataOperations';
/* eslint-disable @typescript-eslint/no-explicit-any */
// Mock the client provider and metadata client
const mockMetadataClient = {
    getAppConnectionConfigsAsync: jest.fn(),
    getAppDataSourceConfigsAsync: jest.fn(),
};
const mockClientProvider = {
    getMetadataClientAsync: jest.fn().mockResolvedValue(mockMetadataClient),
};
describe('RuntimeMetadataOperations', () => {
    let runtimeMetadataOperations;
    beforeEach(() => {
        // Reset all mocks before each test
        jest.clearAllMocks();
        // Reset the client provider mock to its default behavior
        mockClientProvider.getMetadataClientAsync.mockResolvedValue(mockMetadataClient);
        // Create fresh instance for each test
        runtimeMetadataOperations = new RuntimeMetadataOperations(mockClientProvider);
    });
    describe('constructor', () => {
        it('should initialize with client provider', () => {
            // Test: Should initialize with client provider
            // - Verify instance is created successfully
            // - Verify client provider is stored correctly
            expect(runtimeMetadataOperations).toBeInstanceOf(RuntimeMetadataOperations);
            expect(runtimeMetadataOperations).toBeDefined();
        });
    });
    describe('getConnections', () => {
        describe('successful scenarios', () => {
            it('should return connections when client call succeeds', async () => {
                // Test: Should return connections when client call succeeds
                // - Mock successful response from getAppConnectionConfigsAsync
                // - Verify correct IOperationResult structure is returned
                // - Verify data is wrapped in array format
                // - Verify success flag is true
                const mockConnectionData = { id: 'conn1', name: 'Test Connection' };
                mockMetadataClient.getAppConnectionConfigsAsync.mockResolvedValue({
                    success: true,
                    data: mockConnectionData,
                    error: undefined,
                });
                const result = await runtimeMetadataOperations.getConnections();
                expect(result.success).toBe(true);
                expect(result.data).toEqual([mockConnectionData]);
                expect(result.error).toBeUndefined();
                expect(mockMetadataClient.getAppConnectionConfigsAsync).toHaveBeenCalledWith(undefined);
            });
            it('should handle empty data response', async () => {
                // Test: Should handle empty data response
                // - Mock response with undefined/null data
                // - Verify empty array is returned
                // - Verify success flag matches client response
                mockMetadataClient.getAppConnectionConfigsAsync.mockResolvedValue({
                    success: true,
                    data: undefined,
                    error: undefined,
                });
                const result = await runtimeMetadataOperations.getConnections();
                expect(result.success).toBe(true);
                expect(result.data).toEqual([]);
                expect(result.error).toBeUndefined();
            });
            it('should pass operation context to client', async () => {
                // Test: Should pass operation context to client
                // - Provide mock IOperationContext
                // - Verify context is passed through to getAppConnectionConfigsAsync
                const mockContext = { correlationId: 'test-correlation-id' };
                mockMetadataClient.getAppConnectionConfigsAsync.mockResolvedValue({
                    success: true,
                    data: null,
                    error: undefined,
                });
                await runtimeMetadataOperations.getConnections(mockContext);
                expect(mockMetadataClient.getAppConnectionConfigsAsync).toHaveBeenCalledWith(mockContext);
            });
        });
        describe('error scenarios', () => {
            it('should handle client call failure', async () => {
                // Test: Should handle client call failure
                // - Mock failed response from getAppConnectionConfigsAsync
                // - Verify error is propagated in result
                // - Verify success flag is false
                // - Verify data is empty array
                const mockError = new Error('Client call failed');
                mockMetadataClient.getAppConnectionConfigsAsync.mockResolvedValue({
                    success: false,
                    data: undefined,
                    error: mockError,
                });
                const result = await runtimeMetadataOperations.getConnections();
                expect(result.success).toBe(false);
                expect(result.data).toEqual([]);
                expect(result.error).toBe(mockError);
            });
            it('should handle client provider failure', async () => {
                // Test: Should handle client provider failure
                // - Mock getMetadataClientAsync to throw/reject
                // - Verify error handling behavior
                const mockError = new Error('Client provider failed');
                mockClientProvider.getMetadataClientAsync.mockRejectedValue(mockError);
                await expect(runtimeMetadataOperations.getConnections()).rejects.toThrow('Client provider failed');
            });
        });
    });
    describe('getConnectionApis', () => {
        describe('successful scenarios', () => {
            it('should return connection APIs when client call succeeds', async () => {
                // Test: Should return connection APIs when client call succeeds
                // - Mock successful response from getAppDataSourceConfigsAsync
                // - Verify correct IOperationResult structure is returned
                // - Verify data is cast to IConnectionApi and wrapped in array
                // - Verify success flag is true
                const mockApiData = { id: 'api1', name: 'Test API', operations: [] };
                mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                    success: true,
                    data: mockApiData,
                    error: undefined,
                });
                const result = await runtimeMetadataOperations.getConnectionApis('test-connection-id');
                expect(result.success).toBe(true);
                expect(result.data).toEqual([mockApiData]);
                expect(result.error).toBeUndefined();
                expect(mockMetadataClient.getAppDataSourceConfigsAsync).toHaveBeenCalledWith(undefined);
            });
            it('should handle empty data response', async () => {
                // Test: Should handle empty data response
                // - Mock response with undefined/null data
                // - Verify empty array is returned
                // - Verify success flag matches client response
                mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                    success: true,
                    data: undefined,
                    error: undefined,
                });
                const result = await runtimeMetadataOperations.getConnectionApis('test-connection-id');
                expect(result.success).toBe(true);
                expect(result.data).toEqual([]);
                expect(result.error).toBeUndefined();
            });
            it('should pass operation context to client', async () => {
                // Test: Should pass operation context to client
                // - Provide mock IOperationContext
                // - Verify context is passed through to getAppDataSourceConfigsAsync
                const mockContext = { correlationId: 'test-correlation-id' };
                mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                    success: true,
                    data: null,
                    error: undefined,
                });
                await runtimeMetadataOperations.getConnectionApis('test-connection-id', mockContext);
                expect(mockMetadataClient.getAppDataSourceConfigsAsync).toHaveBeenCalledWith(mockContext);
            });
            it('should accept connection ID parameter', async () => {
                // Test: Should accept connection ID parameter
                // - Verify method accepts connectionId parameter
                // - Note: Current implementation doesn't use connectionId (potential improvement area)
                mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                    success: true,
                    data: null,
                    error: undefined,
                });
                const connectionId = 'specific-connection-id';
                await runtimeMetadataOperations.getConnectionApis(connectionId);
                // Note: Current implementation doesn't use connectionId - this is documented as potential improvement
                expect(mockMetadataClient.getAppDataSourceConfigsAsync).toHaveBeenCalled();
            });
        });
        describe('error scenarios', () => {
            it('should handle client call failure', async () => {
                // Test: Should handle client call failure
                // - Mock failed response from getAppDataSourceConfigsAsync
                // - Verify error is propagated in result
                // - Verify success flag is false
                // - Verify data is empty array
                const mockError = new Error('Client call failed');
                mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                    success: false,
                    data: undefined,
                    error: mockError,
                });
                const result = await runtimeMetadataOperations.getConnectionApis('test-connection-id');
                expect(result.success).toBe(false);
                expect(result.data).toEqual([]);
                expect(result.error).toBe(mockError);
            });
            it('should handle client provider failure', async () => {
                // Test: Should handle client provider failure
                // - Mock getMetadataClientAsync to throw/reject
                // - Verify error handling behavior
                const mockError = new Error('Client provider failed');
                mockClientProvider.getMetadataClientAsync.mockRejectedValue(mockError);
                await expect(runtimeMetadataOperations.getConnectionApis('test-connection-id')).rejects.toThrow('Client provider failed');
            });
        });
        describe('edge cases', () => {
            it('should handle null connectionId', async () => {
                // Test: Should handle null/undefined connectionId
                // - Pass null or undefined as connectionId
                // - Verify method doesn't crash (though parameter is unused)
                mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                    success: true,
                    data: null,
                    error: undefined,
                });
                const result = await runtimeMetadataOperations.getConnectionApis(null);
                expect(result.success).toBe(true);
                expect(result.data).toEqual([]);
            });
            it('should handle undefined connectionId', async () => {
                // Test: Should handle null/undefined connectionId
                // - Pass null or undefined as connectionId
                // - Verify method doesn't crash (though parameter is unused)
                mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                    success: true,
                    data: null,
                    error: undefined,
                });
                const result = await runtimeMetadataOperations.getConnectionApis(undefined);
                expect(result.success).toBe(true);
                expect(result.data).toEqual([]);
            });
            it('should handle empty string connectionId', async () => {
                // Test: Should handle empty string connectionId
                // - Pass empty string as connectionId
                // - Verify method behavior
                mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                    success: true,
                    data: null,
                    error: undefined,
                });
                const result = await runtimeMetadataOperations.getConnectionApis('');
                expect(result.success).toBe(true);
                expect(result.data).toEqual([]);
            });
        });
    });
    describe('integration scenarios', () => {
        it('should handle multiple sequential calls', async () => {
            // Test: Should handle multiple sequential calls
            // - Call both getConnections and getConnectionApis
            // - Verify client provider is reused correctly
            // - Verify each call gets fresh client instance
            mockMetadataClient.getAppConnectionConfigsAsync.mockResolvedValue({
                success: true,
                data: { id: 'conn1' },
                error: undefined,
            });
            mockMetadataClient.getAppDataSourceConfigsAsync.mockResolvedValue({
                success: true,
                data: { id: 'api1' },
                error: undefined,
            });
            const connectionsResult = await runtimeMetadataOperations.getConnections();
            const apisResult = await runtimeMetadataOperations.getConnectionApis('test-id');
            expect(connectionsResult.success).toBe(true);
            expect(apisResult.success).toBe(true);
            expect(mockClientProvider.getMetadataClientAsync).toHaveBeenCalledTimes(2);
        });
        it('should handle concurrent calls', async () => {
            // Test: Should handle concurrent calls
            // - Make multiple simultaneous calls to same method
            // - Verify thread safety and proper mock behavior
            mockMetadataClient.getAppConnectionConfigsAsync.mockResolvedValue({
                success: true,
                data: { id: 'conn1' },
                error: undefined,
            });
            const promise1 = runtimeMetadataOperations.getConnections();
            const promise2 = runtimeMetadataOperations.getConnections();
            const promise3 = runtimeMetadataOperations.getConnections();
            const results = await Promise.all([promise1, promise2, promise3]);
            results.forEach((result) => {
                expect(result.success).toBe(true);
                expect(result.data).toEqual([{ id: 'conn1' }]);
            });
            expect(mockClientProvider.getMetadataClientAsync).toHaveBeenCalledTimes(3);
        });
    });
});
/* eslint-enable @typescript-eslint/no-explicit-any */
//# sourceMappingURL=runtimeMetadataOperations.test.js.map