/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { afterEach, beforeEach, describe, it, jest } from '@jest/globals';
import { getPowerDataRuntime, resetPowerDataRuntimeInstance, } from '../internal/data/core/runtime/powerDataRuntimeInstance';
import { Log } from '../internal/data/core/telemetry/log';
// Mock Log.resetInstance
jest.mock('../internal/data/core/telemetry/log', () => ({
    Log: {
        resetInstance: jest.fn(),
    },
}));
jest.mock('../internal/data/core/runtime/powerDataRuntime', () => {
    return {
        PowerDataRuntime: jest.fn().mockImplementation(() => {
            return {
                _clientProvider: {},
                _dataSourceService: {},
                _xrm: {},
                _isInitialized: true,
            };
        }),
    };
});
describe('powerDataRuntimeInstance', () => {
    let mockPowerDataSourcesInfoProvider;
    let mockPowerOperationExecutor;
    beforeEach(() => {
        // Setup mock objects before each test
        mockPowerDataSourcesInfoProvider = {
            getDataSourcesInfo: jest.fn(),
        };
        mockPowerOperationExecutor = {
            execute: jest
                .fn()
                .mockImplementation(() => Promise.resolve({ success: true, data: null })),
        };
        // Configure mock return values after creation
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        mockPowerDataSourcesInfoProvider.getDataSourcesInfo.mockResolvedValue({});
        jest.clearAllMocks();
    });
    afterEach(() => {
        // Reset singleton instance to ensure test isolation
        resetPowerDataRuntimeInstance();
        jest.clearAllMocks();
    });
    describe('getPowerDataRuntime', () => {
        describe('when called for the first time', () => {
            it('should create a new PowerDataRuntime instance with required parameters', () => {
                // Test that a new instance is created when none exists
                // Verify PowerDataRuntime constructor is called with correct parameters
                // Assert that the returned instance is the created one
                const result = getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor);
                expect(result).toBeDefined();
            });
            it('should create instance with default xrm context when xrm parameter is not provided', () => {
                // Test that default xrm context ({ WebApi: {} }) is used when xrm is undefined
                // Verify PowerDataRuntime constructor receives default xrm object
                const result = getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor);
                expect(result).toBeDefined();
            });
        });
        describe('when called multiple times', () => {
            it('should return the same singleton instance on subsequent calls', () => {
                // Test singleton behavior - same instance returned on multiple calls
                // Verify PowerDataRuntime constructor is only called once
                // Assert that both calls return the same instance reference
                const firstCall = getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor);
                const secondCall = getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor);
                expect(firstCall).toBe(secondCall);
            });
            it('should ignore different parameters on subsequent calls and return existing instance', () => {
                // Test that passing different parameters on second call doesn't create new instance
                // Verify that the original instance is returned regardless of new parameters
                const firstCall = getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor);
                const differentProvider = {
                    getDataSourcesInfo: jest.fn().mockImplementation(() => Promise.resolve({ different: true })),
                };
                const secondCall = getPowerDataRuntime(differentProvider, mockPowerOperationExecutor);
                expect(firstCall).toBe(secondCall);
            });
        });
        describe('parameter validation', () => {
            it('should handle null powerDataSourcesInfoProvider parameter', () => {
                // Test behavior when powerDataSourcesInfoProvider is null
                // Verify appropriate handling or error throwing
                expect(() => {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    getPowerDataRuntime(null, mockPowerOperationExecutor);
                }).not.toThrow();
            });
            it('should handle null powerOperationExecutor parameter', () => {
                // Test behavior when powerOperationExecutor is null
                // Verify appropriate handling or error throwing
                expect(() => {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    getPowerDataRuntime(mockPowerDataSourcesInfoProvider, null);
                }).not.toThrow();
            });
        });
    });
    describe('resetPowerDataRuntimeInstance', () => {
        it('should reset the Log instance', () => {
            // Test that Log.resetInstance() is called when resetting
            // Verify Log singleton is also reset for clean state
            const mockLogReset = jest.spyOn(Log, 'resetInstance');
            resetPowerDataRuntimeInstance();
            expect(mockLogReset).toHaveBeenCalledTimes(1);
            mockLogReset.mockRestore();
        });
        it('should allow creating new instance after reset', () => {
            // Test complete reset workflow
            // Create instance -> reset -> create new instance
            // Verify new instance is different from the original
            const firstInstance = getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor);
            resetPowerDataRuntimeInstance();
            const secondInstance = getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor);
            expect(firstInstance).not.toBe(secondInstance);
        });
    });
    describe('integration scenarios', () => {
        it('should handle multiple reset and create cycles', () => {
            // Test multiple cycles of create -> reset -> create
            // Verify each cycle produces clean instances
            const instances = [];
            for (let i = 0; i < 3; i++) {
                const instance = getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor);
                instances.push(instance);
                resetPowerDataRuntimeInstance();
            }
            // Verify all instances are different
            expect(instances[0]).not.toBe(instances[1]);
            expect(instances[1]).not.toBe(instances[2]);
            expect(instances[0]).not.toBe(instances[2]);
        });
        it('should maintain singleton behavior across async operations', async () => {
            // Test singleton behavior in concurrent/async scenarios
            // Verify thread safety and consistency
            const promises = Array.from({ length: 5 }, () => Promise.resolve().then(() => getPowerDataRuntime(mockPowerDataSourcesInfoProvider, mockPowerOperationExecutor)));
            const instances = await Promise.all(promises);
            // All instances should be the same reference
            instances.forEach((instance, index) => {
                if (index > 0) {
                    expect(instance).toBe(instances[0]);
                }
            });
        });
    });
    describe('error handling', () => {
        it('should handle Log.resetInstance throwing an error during reset', () => {
            // Test behavior when Log.resetInstance fails
            // Verify error handling and partial reset scenarios
            const mockLogReset = jest.spyOn(Log, 'resetInstance').mockImplementation(() => {
                throw new Error('Log reset failed');
            });
            expect(() => {
                resetPowerDataRuntimeInstance();
            }).toThrow('Log reset failed');
            mockLogReset.mockRestore();
        });
    });
});
//# sourceMappingURL=powerDataRuntimeInstance.test.js.map