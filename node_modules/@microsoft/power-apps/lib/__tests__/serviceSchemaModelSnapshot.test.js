/*
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import fs from 'fs';
import path from 'path';
const pairs = [
    {
        label: 'Office365Users',
        schema: './mocks/schemas/office365users/office365users.Schema.json',
        service: './mocks/generated/services/Office365UsersService.ts',
    },
    {
        label: 'Office365Groups',
        schema: './mocks/schemas/office365groups/office365groups.Schema.json',
        service: './mocks/generated/services/Office365GroupsService.ts',
    },
    {
        label: 'MSNWeather',
        schema: './mocks/schemas/msnweather/msnweather.Schema.json',
        service: './mocks/generated/services/MSNWeatherService.ts',
    },
    {
        label: 'OneDriveforBusiness',
        schema: './mocks/schemas/onedriveforbusiness/onedriveforbusiness.Schema.json',
        service: './mocks/generated/services/OneDriveforBusinessService.ts',
    },
    {
        label: 'PowerAppsforMakers',
        schema: './mocks/schemas/powerappsforappmakers/powerappsforappmakers.Schema.json',
        service: './mocks/generated/services/PowerAppsforMakersService.ts',
    },
    {
        label: 'MicrosoftTeams',
        schema: './mocks/schemas/teams/teams.Schema.json',
        service: './mocks/generated/services/MicrosoftTeamsService.ts',
    },
    {
        label: 'MicrosoftTranslatorV2',
        schema: './mocks/schemas/translatorv2/translatorv2.Schema.json',
        service: './mocks/generated/services/MicrosoftTranslatorV2Service.ts',
    },
    {
        label: 'Kusto',
        schema: './mocks/schemas/kusto/kusto.Schema.json',
        service: './mocks/generated/services/AzureDataExplorerService.ts',
    },
];
describe('Schema vs Service function count and names (all pairs)', () => {
    for (const { label, schema, service } of pairs) {
        it(`should match function count and names for ${label}`, () => {
            const schemaPath = path.resolve(__dirname, schema);
            let servicePath = path.resolve(__dirname, service + '.txt');
            if (!fs.existsSync(servicePath)) {
                servicePath = path.resolve(__dirname, service);
            }
            // --- SCHEMA FUNCTION NAMES ---
            const schemaObj = JSON.parse(fs.readFileSync(schemaPath, 'utf-8'));
            const pathsObj = schemaObj.properties?.swagger?.paths || {};
            const schemaFunctionNames = [];
            for (const key in pathsObj) {
                if (Object.prototype.hasOwnProperty.call(pathsObj, key)) {
                    const methods = Object.keys(pathsObj[key]);
                    for (const method of methods) {
                        if (['get', 'post', 'put', 'patch', 'delete'].includes(method)) {
                            const opId = pathsObj[key][method]?.operationId;
                            if (opId) {
                                schemaFunctionNames.push(opId);
                            }
                            else {
                                schemaFunctionNames.push(`${method}_${key}`);
                            }
                        }
                    }
                }
            }
            // --- SERVICE FUNCTION NAMES ---
            const serviceText = fs.readFileSync(servicePath, 'utf-8');
            const staticAsyncMethodRegex = /public\s+static\s+async\s+(\w+)\s*\(/g;
            const serviceFunctionNames = [];
            let match;
            while (true) {
                match = staticAsyncMethodRegex.exec(serviceText);
                if (match === null) {
                    break;
                }
                serviceFunctionNames.push(match[1]);
            }
            // --- NORMALIZATION ---
            const normalize = (name) => name.toLowerCase().replace(/[^a-z0-9]/g, '');
            const normalizedSchemaNames = schemaFunctionNames.map(normalize).sort();
            const normalizedServiceNames = serviceFunctionNames.map(normalize).sort();
            // --- ASSERTIONS ---
            expect(normalizedSchemaNames.length).toBe(normalizedServiceNames.length);
            expect(normalizedSchemaNames).toEqual(normalizedServiceNames);
        });
    }
});
//# sourceMappingURL=serviceSchemaModelSnapshot.test.js.map