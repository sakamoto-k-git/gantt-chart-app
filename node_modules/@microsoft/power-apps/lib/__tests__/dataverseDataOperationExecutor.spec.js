/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { DataverseDataOperationExecutor, extractSkipToken, ODATA_NEXT_LINK, } from '../internal/data/core/data/executors/dataverseDataOperationExecutor';
import { afterEach, beforeEach, describe, expect, it } from '@jest/globals';
describe('DataverseDataOperationExecutor', () => {
    let instance;
    let mockClientProvider;
    let mockDataClient;
    beforeEach(() => {
        mockDataClient = {
            createDataAsync: jest.fn(),
            updateDataAsync: jest.fn(),
            deleteDataAsync: jest.fn(),
            retrieveDataAsync: jest.fn(),
        };
        mockClientProvider = {
            getDataClientAsync: jest.fn().mockResolvedValue(mockDataClient),
            getMetadataClientAsync: jest.fn().mockResolvedValue({
                getAppDataSourceConfigsAsync: jest.fn().mockResolvedValue({
                    success: true,
                    data: {
                        Accounts: {
                            runtimeUrl: 'https://org123.crm.dynamics.com/api/data/v9.2/',
                            entitySetName: 'Accounts',
                            logicalName: 'account',
                            version: '9.2.25062.146',
                        },
                    },
                }),
            }),
        };
        instance = new DataverseDataOperationExecutor(mockClientProvider);
        // Reset the database references cache at the start of each test
        instance._databaseReferences = null;
    });
    // Clear the _databaseReferences cache before each test to ensure fresh mocks are used
    afterEach(() => {
        instance._databaseReferences = null;
    });
    it('should parse and return databaseReferences correctly', async () => {
        const refs = await instance.getDatabaseReferences();
        expect(refs['default.cds']).toBeDefined();
        expect(refs['default.cds'].databaseDetails.environmentName).toBe('default.cds');
        expect(refs['default.cds'].dataSources.Accounts.entitySetName).toBe('Accounts');
    });
    it('should call createDataAsync for createRecordAsync (connector style)', async () => {
        mockDataClient.createDataAsync.mockResolvedValue({ success: true, data: { id: '1' } });
        const result = await instance.createRecordAsync('Accounts', { name: 'Test' });
        expect(mockDataClient.createDataAsync).toHaveBeenCalled();
        expect(result.success).toBe(true);
        expect(result.data).toEqual({ id: '1' });
    });
    it('should pass headers object to createDataAsync', async () => {
        mockDataClient.createDataAsync.mockResolvedValue({ success: true, data: { id: '1' } });
        await instance.createRecordAsync('Accounts', { name: 'Test' });
        const contextArg = mockDataClient.createDataAsync.mock.calls[0][4];
        expect(contextArg).toBeDefined();
        if (contextArg && contextArg.headers) {
            expect(contextArg.headers).toEqual(expect.objectContaining({
                'Content-Type': expect.stringMatching(/application\/json/),
                Authorization: expect.stringMatching(/^Bearer /),
                Prefer: expect.stringContaining('return=representation'),
            }));
        }
    });
    it('should pass correct headers to createDataAsync for createRecordAsync', async () => {
        mockDataClient.createDataAsync.mockResolvedValue({ success: true, data: { id: '1' } });
        await instance.createRecordAsync('Accounts', { name: 'Test' });
        const contextArg = mockDataClient.createDataAsync.mock.calls[0][4];
        expect(contextArg).toBeDefined();
        // Only check headers if present
        if (contextArg.headers) {
            expect(contextArg.headers).toEqual(expect.objectContaining({
                'Content-Type': expect.stringMatching(/application\/json/),
                Authorization: expect.stringMatching(/^Bearer /),
                Prefer: expect.stringContaining('return=representation'),
            }));
        }
        else {
            expect(contextArg.headers).toBeUndefined();
        }
    });
    it('should call updateDataAsync for updateRecordAsync (connector style)', async () => {
        mockDataClient.updateDataAsync.mockResolvedValue({ success: true, data: { id: '1', name: 'Updated' } });
        const result = await instance.updateRecordAsync('Accounts', '1', { name: 'Updated' });
        expect(mockDataClient.updateDataAsync).toHaveBeenCalled();
        expect(result.success).toBe(true);
        expect(result.data).toEqual({ id: '1', name: 'Updated' });
    });
    it('should pass headers object to updateDataAsync', async () => {
        mockDataClient.updateDataAsync.mockResolvedValue({ success: true, data: { id: '1', name: 'Updated' } });
        await instance.updateRecordAsync('Accounts', '1', { name: 'Updated' });
        const contextArg = mockDataClient.updateDataAsync.mock.calls[0][4];
        expect(contextArg).toBeDefined();
        if (contextArg && contextArg.headers) {
            expect(contextArg.headers).toEqual(expect.objectContaining({
                'Content-Type': expect.stringMatching(/application\/json/),
                Authorization: expect.stringMatching(/^Bearer /),
                Prefer: expect.stringContaining('return=representation'),
                'If-Match': expect.any(String),
            }));
        }
    });
    it('should pass correct headers to updateDataAsync for updateRecordAsync', async () => {
        mockDataClient.updateDataAsync.mockResolvedValue({ success: true, data: { id: '1', name: 'Updated' } });
        await instance.updateRecordAsync('Accounts', '1', { name: 'Updated' });
        const contextArg = mockDataClient.updateDataAsync.mock.calls[0][4];
        expect(contextArg).toBeDefined();
        if (contextArg.headers) {
            expect(contextArg.headers).toEqual(expect.objectContaining({
                'Content-Type': expect.stringMatching(/application\/json/),
                Authorization: expect.stringMatching(/^Bearer /),
                Prefer: expect.stringContaining('return=representation'),
                'If-Match': expect.any(String),
            }));
        }
        else {
            expect(contextArg.headers).toBeUndefined();
        }
    });
    it('should call deleteDataAsync for deleteRecordAsync (connector style)', async () => {
        mockDataClient.deleteDataAsync.mockResolvedValue({ success: true });
        const result = await instance.deleteRecordAsync('Accounts', '1');
        expect(mockDataClient.deleteDataAsync).toHaveBeenCalled();
        expect(result.success).toBe(true);
    });
    it('should pass headers object to deleteDataAsync', async () => {
        mockDataClient.deleteDataAsync.mockResolvedValue({ success: true });
        await instance.deleteRecordAsync('Accounts', '1');
        const contextArg = mockDataClient.deleteDataAsync.mock.calls[0][3];
        expect(contextArg).toBeDefined();
        if (contextArg && contextArg.headers) {
            expect(contextArg.headers).toEqual(expect.objectContaining({
                Authorization: expect.stringMatching(/^Bearer /),
                Prefer: expect.stringContaining('return=representation'),
                'If-Match': expect.any(String),
            }));
        }
    });
    it('should pass correct headers to deleteDataAsync for deleteRecordAsync', async () => {
        mockDataClient.deleteDataAsync.mockResolvedValue({ success: true });
        await instance.deleteRecordAsync('Accounts', '1');
        const contextArg = mockDataClient.deleteDataAsync.mock.calls[0][3];
        expect(contextArg).toBeDefined();
        if (contextArg.headers) {
            expect(contextArg.headers).toEqual(expect.objectContaining({
                Authorization: expect.stringMatching(/^Bearer /),
                Prefer: expect.stringContaining('return=representation'),
                'If-Match': expect.any(String),
            }));
        }
        else {
            expect(contextArg.headers).toBeUndefined();
        }
    });
    it('should call retrieveDataAsync for retrieveRecordAsync (connector style) and pass Prefer header', async () => {
        mockDataClient.retrieveDataAsync.mockResolvedValue({ success: true, data: { id: '1', name: 'Test' } });
        const result = await instance.retrieveRecordAsync('Accounts', '1', { maxPageSize: 42 });
        expect(mockDataClient.retrieveDataAsync).toHaveBeenCalledWith('https://org123.crm.dynamics.com/api/data/v9.0/Accounts(1)', 'Dataverse', 'Accounts', 'GET', expect.objectContaining({ Prefer: expect.stringContaining('odata.maxpagesize=42') }), undefined, {
            datasetName: 'default.cds',
            isDataVerseOperation: true,
            operationName: 'dataverseDataOperation.retrieveRecordAsync',
        });
        expect(result.success).toBe(true);
        expect(result.data).toEqual({ id: '1', name: 'Test' });
    });
    it('should call retrieveDataAsync for retrieveMultipleRecordsAsync (connector style) and pass Prefer header', async () => {
        mockDataClient.retrieveDataAsync.mockResolvedValue({
            success: true,
            data: { value: [{ id: '1' }, { id: '2' }] },
        });
        const result = await instance.retrieveMultipleRecordsAsync('Accounts', { maxPageSize: 99 });
        expect(mockDataClient.retrieveDataAsync).toHaveBeenCalledWith(expect.any(String), expect.any(String), expect.any(String), expect.any(String), expect.objectContaining({ Prefer: expect.stringContaining('odata.maxpagesize=99') }), undefined, expect.any(Object));
        expect(result.success).toBe(true);
        expect(result.data).toEqual([{ id: '1' }, { id: '2' }]);
    });
    it('should handle errors and return error response', async () => {
        // Mock the createDataAsync to return an error response structure
        mockDataClient.createDataAsync.mockResolvedValue({
            success: false,
            error: new Error('Network error occurred'),
            data: undefined,
        });
        const result = await instance.createRecordAsync('Accounts', { name: 'fail' });
        expect(result.success).toBe(false);
        expect(result.error).toBeDefined();
        expect(result.error?.message).toContain('Network error occurred');
    });
    it('should generate correct URL for createRecordAsync', async () => {
        mockDataClient.createDataAsync.mockResolvedValue({ success: true, data: { id: '1' } });
        await instance.createRecordAsync('Accounts', { name: 'Test' });
        expect(mockDataClient.createDataAsync.mock.calls[0][0]).toBe('https://org123.crm.dynamics.com/api/data/v9.0/Accounts');
    });
    it('should generate correct URL for updateRecordAsync', async () => {
        mockDataClient.updateDataAsync.mockResolvedValue({ success: true, data: { id: '1', name: 'Updated' } });
        await instance.updateRecordAsync('Accounts', '1', { name: 'Updated' });
        expect(mockDataClient.updateDataAsync.mock.calls[0][0]).toBe('https://org123.crm.dynamics.com/api/data/v9.0/Accounts(1)');
    });
    it('should generate correct URL for deleteRecordAsync', async () => {
        mockDataClient.deleteDataAsync.mockResolvedValue({ success: true });
        await instance.deleteRecordAsync('Accounts', '1');
        expect(mockDataClient.deleteDataAsync.mock.calls[0][0]).toBe('https://org123.crm.dynamics.com/api/data/v9.0/Accounts(1)');
    });
    it('should generate correct URL for retrieveRecordAsync', async () => {
        mockDataClient.retrieveDataAsync.mockResolvedValue({ success: true, data: { id: '1', name: 'Test' } });
        await instance.retrieveRecordAsync('Accounts', '1', { select: ['Name', 'Age'], maxPageSize: 42 });
        expect(mockDataClient.retrieveDataAsync.mock.calls[0][0]).toBe('https://org123.crm.dynamics.com/api/data/v9.0/Accounts(1)?$select=Name%2CAge');
    });
    it('should generate correct URL for retrieveMultipleRecordsAsync', async () => {
        mockDataClient.retrieveDataAsync.mockResolvedValue({
            success: true,
            data: {
                value: [{ id: '1' }, { id: '2' }],
                [ODATA_NEXT_LINK]: 'https://org123.crm.dynamics.com/api/data/v9.0/Accounts?$skiptoken=abc123',
            },
        });
        await instance.retrieveMultipleRecordsAsync('Accounts', { maxPageSize: 99 });
        expect(mockDataClient.retrieveDataAsync.mock.calls[0][0]).toBe('https://org123.crm.dynamics.com/api/data/v9.0/Accounts');
    });
    it('should generate correct URL for retrieveMultipleRecordsAsync with skip token', async () => {
        mockDataClient.retrieveDataAsync.mockResolvedValue({
            success: true,
            data: {
                value: [{ id: '1' }, { id: '2' }],
            },
        });
        // the options parameter is generated when the user calls runtimeDataOperation.retrieveMultipleRecordsAsync
        // callers never call the dataverseDartabaseOperation.retrieveMultipleRecordsAsync directly
        const result = await instance.retrieveMultipleRecordsAsync('Accounts', {
            skipToken: 'abc123',
            maxPageSize: 99,
        });
        // Verify the URL includes the skip token
        expect(mockDataClient.retrieveDataAsync.mock.calls[0][0]).toBe('https://org123.crm.dynamics.com/api/data/v9.0/Accounts?$skiptoken=abc123');
        expect(result.success).toBe(true);
        expect(result.data).toEqual([{ id: '1' }, { id: '2' }]);
    });
    it('should handle nextLink with skip token in retrieveMultipleRecordsAsync response', async () => {
        mockDataClient.retrieveDataAsync.mockResolvedValue({
            success: true,
            data: {
                value: [{ id: '1' }, { id: '2' }],
                [ODATA_NEXT_LINK]: 'https://org123.crm.dynamics.com/api/data/v9.0/Accounts?$skiptoken=abc123',
            },
        });
        const result = await instance.retrieveMultipleRecordsAsync('Accounts', { maxPageSize: 99 });
        expect(mockDataClient.retrieveDataAsync.mock.calls[0][0]).toBe('https://org123.crm.dynamics.com/api/data/v9.0/Accounts');
        expect(result.success).toBe(true);
        expect(result.data).toEqual([{ id: '1' }, { id: '2' }]);
        expect(result.skipToken).toBe('abc123');
    });
    it('should handle multiple pages of data in retrieveMultipleRecordsAsync', async () => {
        mockDataClient.retrieveDataAsync.mockResolvedValueOnce({
            success: true,
            data: {
                value: [{ id: '1' }, { id: '2' }],
                [ODATA_NEXT_LINK]: 'https://org123.crm.dynamics.com/api/data/v9.0/Accounts?$skiptoken=page2',
            },
        });
        mockDataClient.retrieveDataAsync.mockResolvedValueOnce({
            success: true,
            data: {
                value: [{ id: '3' }, { id: '4' }],
                [ODATA_NEXT_LINK]: 'https://org123.crm.dynamics.com/api/data/v9.0/Accounts?$skiptoken=page4',
            },
        });
        mockDataClient.retrieveDataAsync.mockResolvedValueOnce({
            success: true,
            data: {
                value: [{ id: '81' }, { id: '82' }],
                [ODATA_NEXT_LINK]: 'https://org123.crm.dynamics.com/api/data/v9.0/Accounts?$skiptoken=page82',
            },
        });
        const firstPage = await instance.retrieveMultipleRecordsAsync('Accounts', { maxPageSize: 99 });
        expect(firstPage.success).toBe(true);
        expect(firstPage.data).toEqual([{ id: '1' }, { id: '2' }]);
        expect(firstPage.skipToken).toBe('page2');
        const secondPage = await instance.retrieveMultipleRecordsAsync('Accounts', {
            skipToken: firstPage.skipToken,
            maxPageSize: 99,
        });
        expect(secondPage.success).toBe(true);
        expect(secondPage.data).toEqual([{ id: '3' }, { id: '4' }]);
        expect(secondPage.skipToken).toBe('page4');
        const thirdPage = await instance.retrieveMultipleRecordsAsync('Accounts', {
            skipToken: secondPage.skipToken,
            maxPageSize: 99,
        });
        expect(thirdPage.success).toBe(true);
        expect(thirdPage.data).toEqual([{ id: '81' }, { id: '82' }]);
        expect(thirdPage.skipToken).toBe('page82');
    });
    describe('extractSkipToken', () => {
        it('should extract skip token from nextLink', () => {
            const nextLink = `https://contosso.com/api/data/v9.0/accounts?$skiptoken=%3Ccookie%20pagenumber=%222%22%20pagingcookie=%22%253ccookie%2520page%253d%25221%2522%253e%253caccountid%2520last%253d%2522%257b717FCF9A-0CF6-EF11-BAE1-6045BD008D1B%257d%2522%2520first%253d%2522%257b84A47482-5252-F011-BEC1-000D3A3129E9%257d%2522%2520%252f%253e%253c%252fcookie%253e%22%20istracking=%22False%22%20/%3E`;
            const result = extractSkipToken(nextLink);
            expect(result).toBe('<cookie pagenumber="2" pagingcookie="%3ccookie%20page%3d%221%22%3e%3caccountid%20last%3d%22%7b717FCF9A-0CF6-EF11-BAE1-6045BD008D1B%7d%22%20first%3d%22%7b84A47482-5252-F011-BEC1-000D3A3129E9%7d%22%20%2f%3e%3c%2fcookie%3e" istracking="False" />');
        });
        it('should return undefined if skip token is not present', () => {
            const nextLink = 'https://org123.crm.dynamics.com/api/data/v9.0/Accounts';
            const result = extractSkipToken(nextLink);
            expect(result).toBeUndefined();
        });
    });
});
//# sourceMappingURL=dataverseDataOperationExecutor.spec.js.map