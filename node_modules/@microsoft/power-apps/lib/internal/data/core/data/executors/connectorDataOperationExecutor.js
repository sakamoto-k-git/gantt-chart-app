/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { HttpMethod, } from '../../common/types';
import { createErrorResponse, DataOperationErrorMessages, ErrorCodes, PowerDataRuntimeError, } from '../../error/error';
import { ConnectorOperationName } from '../../error/constants';
import { convertOptionsToQueryString } from './shared/stringQueryOptions';
// =====================================
// Main Class Implementation
// =====================================
/**
 * ConnectorDataOperation provides functionality for performing CRUD operations
 * against connector data sources using the Runtime Data Client.
 */
export class ConnectorDataOperationExecutor {
    // =====================================
    // Private Members
    // =====================================
    _clientProvider;
    _connectionsService;
    _databaseReferences;
    _connectionReferences;
    // =====================================
    // Constructor
    // =====================================
    constructor(clientProvider, connectionsService) {
        this._validateConstructorParams(clientProvider, connectionsService);
        this._clientProvider = clientProvider;
        this._connectionsService = connectionsService;
    }
    // =====================================
    // Public Methods
    // =====================================
    /**
     * Creates a new record in the specified table
     */
    async createRecordAsync(tableName, data) {
        try {
            const { dataClient, connectionReference } = await this._getClientsAndConnection(tableName);
            const requestUrl = await this._buildTableUrl(tableName, connectionReference);
            const result = await dataClient.createDataAsync(requestUrl, connectionReference.apiId, tableName, data, { operationName: ConnectorOperationName.CreateRecord });
            return result;
        }
        catch (error) {
            return createErrorResponse(error, DataOperationErrorMessages.CreateFailed);
        }
    }
    /**
     * Updates an existing record in the specified table
     */
    async updateRecordAsync(tableName, id, data) {
        try {
            const { dataClient, connectionReference } = await this._getClientsAndConnection(tableName);
            const requestUrl = await this._buildTableUrl(tableName, connectionReference, `/${id}`);
            const result = await dataClient.updateDataAsync(requestUrl, connectionReference.apiId, tableName, data, { operationName: ConnectorOperationName.UpdateRecord });
            return result;
        }
        catch (error) {
            return createErrorResponse(error, DataOperationErrorMessages.UpdateFailed);
        }
    }
    /**
     * Deletes a record from the specified table
     */
    async deleteRecordAsync(tableName, id) {
        try {
            const { dataClient, connectionReference } = await this._getClientsAndConnection(tableName);
            const requestUrl = await this._buildTableUrl(tableName, connectionReference, `/${id}`);
            const result = await dataClient.deleteDataAsync(requestUrl, connectionReference.apiId, tableName, { operationName: ConnectorOperationName.DeleteRecord });
            return result;
        }
        catch (error) {
            return createErrorResponse(error, DataOperationErrorMessages.DeleteFailed);
        }
    }
    /**
     * Retrieves a single record from the specified table
     */
    async retrieveRecordAsync(tableName, id, options) {
        try {
            const { dataClient, connectionReference } = await this._getClientsAndConnection(tableName);
            const requestUrl = await this._buildTableUrl(tableName, connectionReference, `/${id}${convertOptionsToQueryString(options)}`);
            const result = await dataClient.retrieveDataAsync(requestUrl, connectionReference.apiId, tableName, HttpMethod.GET, undefined, // body
            { operationName: ConnectorOperationName.RetrieveRecord });
            return result;
        }
        catch (error) {
            return createErrorResponse(error, DataOperationErrorMessages.RetrieveFailed);
        }
    }
    /**
     * Retrieves multiple records from the specified table
     */
    async retrieveMultipleRecordsAsync(tableName, options) {
        try {
            const { dataClient, connectionReference } = await this._getClientsAndConnection(tableName);
            const requestUrl = await this._buildTableUrl(tableName, connectionReference, convertOptionsToQueryString(options), false);
            const result = await dataClient.retrieveDataAsync(requestUrl, connectionReference.apiId, tableName, HttpMethod.GET, undefined, // body
            { operationName: ConnectorOperationName.RetrieveMultipleRecords });
            return result;
        }
        catch (error) {
            return createErrorResponse(error, DataOperationErrorMessages.RetrieveMultipleFailed);
        }
    }
    /**
     * Executes a custom operation on the data source
     */
    async executeAsync(operation) {
        try {
            if (!operation?.connectorOperation) {
                throw new Error(`${DataOperationErrorMessages.InvalidRequest}: ${DataOperationErrorMessages.MissingConnectorOperation}`);
            }
            const tableName = operation.connectorOperation.tableName;
            const dataSourceInfo = await this._connectionsService.getDataSource(tableName);
            const { dataClient, connectionReference } = await this._getClientsAndConnection(tableName);
            const config = await this._getOperationConfig(operation, connectionReference, tableName);
            const requestUrl = await this._buildOperationUrl(operation, config);
            const bodyParam = await this._buildOperationBody(operation, tableName);
            const headers = await this._buildOperationHeader(operation, tableName);
            const httpMethod = this._getHttpMethod(requestUrl, dataSourceInfo, operation.connectorOperation.operationName);
            const responseInfo = dataSourceInfo.apis[operation.connectorOperation.operationName]?.responseInfo;
            const result = await dataClient.retrieveDataAsync(requestUrl, config.apiId, tableName, httpMethod, headers, bodyParam, {
                isExecuteAsync: true,
                // Use the connector operation name for telemetry, may be a better idea to use executeAsync
                // here and just log the connector operation name in the custom dimensions leaving comment for PR.
                operationName: `connectorDataOperation.${operation.connectorOperation.operationName}`,
                responseInfo,
            });
            return result;
        }
        catch (error) {
            return createErrorResponse(error, DataOperationErrorMessages.ExecuteFailed);
        }
    }
    // =====================================
    // Private Methods
    // =====================================
    /**
     * Determines the appropriate HTTP method for a request
     * @param requestUrl - The URL for the request
     * @param dataSourceInfo - The data source information
     * @param operation - The operation name
     * @returns The HTTP method to use
     */
    _getHttpMethod(requestUrl, dataSourceInfo, operation) {
        // Check if it's a SQL stored procedure (which requires POST)
        const isSqlStoredProcedure = requestUrl.indexOf('apim/sql') > -1;
        // Default to POST for SQL procedures, GET otherwise
        if (isSqlStoredProcedure) {
            return HttpMethod.POST;
        }
        const method = dataSourceInfo.apis[operation]?.method;
        if (method) {
            return method;
        }
        return HttpMethod.GET;
    }
    /**
     * Builds the operation body parameters
     */
    async _buildOperationBody(operation, tableName) {
        const operationName = operation?.connectorOperation?.operationName;
        if (operationName) {
            const dataSourceInfo = await this._connectionsService.getDataSource(tableName);
            const hasBodyParameter = dataSourceInfo?.apis?.[operationName]?.parameters?.some((param) => param.in === 'body');
            if (hasBodyParameter) {
                return await this._buildOperationBodyParam(operation, tableName);
            }
        }
        return undefined;
    }
    /**
     * Builds operation body parameters from the operation and data source info
     */
    async _buildOperationBodyParam(operation, tableName) {
        const operationName = operation.connectorOperation?.operationName;
        if (!operationName) {
            return '{}';
        }
        const dataSourceInfo = await this._connectionsService.getDataSource(tableName);
        const apiParams = dataSourceInfo?.apis?.[operationName]?.parameters || [];
        const rawParams = operation.connectorOperation?.parameters || [];
        let bodyValue = {};
        apiParams.forEach((param, index) => {
            if (typeof rawParams === 'object' && rawParams !== null) {
                if (apiParams[index].in === 'body') {
                    const value = rawParams[param.name];
                    if (param.name === 'body') {
                        bodyValue = value;
                        return;
                    }
                    if (value !== undefined && value !== null) {
                        bodyValue[param.name] = value;
                    }
                }
            }
        });
        return JSON.stringify(bodyValue);
    }
    /**
     * Builds the operation header for a given data operation if required.
     *
     * @template TRequest - The type of the request payload for the data operation.
     * @param dataOperationRequest - The data operation containing details about the connector operation.
     * @param tableName - The name of the table associated with the data operation.
     * @returns A promise that resolves to the operation header as a string if a header parameter is required,
     *          or `undefined` if no header parameter is needed.
     */
    async _buildOperationHeader(dataOperationRequest, tableName) {
        const operationName = dataOperationRequest.connectorOperation?.operationName;
        if (operationName) {
            const dataSourceInfo = await this._connectionsService.getDataSource(tableName);
            const hasHeaderParameter = dataSourceInfo?.apis?.[operationName]?.parameters?.some((param) => param.in === 'header');
            if (hasHeaderParameter) {
                return await this._buildOperationHeaderParam(dataOperationRequest, tableName);
            }
        }
        return undefined;
    }
    /**
     * Builds the operation header parameters as a JSON string for a given data operation.
     *
     * @template TRequest - The type of the request object for the data operation.
     * @param dataOperationRequest - The data operation containing connector operation details and parameters.
     * @param tableName - The name of the table associated with the data operation.
     * @returns A promise that resolves to a JSON string representing the header parameters,
     *          or `undefined` if no `header` parameters are available.
     */
    async _buildOperationHeaderParam(dataOperationRequest, tableName) {
        const operationName = dataOperationRequest.connectorOperation?.operationName;
        if (!operationName) {
            return {};
        }
        const dataSourceInfo = await this._connectionsService.getDataSource(tableName);
        const apiParamSpec = dataSourceInfo?.apis?.[operationName]?.parameters || [];
        const inputParams = dataOperationRequest.connectorOperation?.parameters;
        const headers = {};
        // This method does not check for required header parameters
        // If the header parameter is required & is not provided, the connector will throw an error
        // when the operation is executed.
        if (!inputParams) {
            return undefined;
        }
        if (typeof inputParams === 'string') {
            // Handle string parameter - often used for single parameter operations
            if (apiParamSpec.length === 1 && apiParamSpec[0].in === 'header') {
                headers[apiParamSpec[0].name] = inputParams;
            }
        }
        if (typeof inputParams === 'object' && !Array.isArray(inputParams)) {
            // Handle object parameters - match by parameter name
            apiParamSpec.forEach((param) => {
                if (param.in === 'header' && param.name in inputParams) {
                    headers[param.name] = inputParams[param.name];
                }
            });
        }
        if (Array.isArray(inputParams)) {
            // Handle array parameters - match by index
            apiParamSpec.forEach((param, index) => {
                if (param.in === 'header' && inputParams[index] !== undefined) {
                    headers[param.name] = inputParams[index];
                }
            });
        }
        return headers;
    }
    /**
     * Constructs the request URL for table operations
     * @param tableName - The name of the table
     * @param connectionReference - The connection reference
     * @param options - Optional URL parameters
     * @param encodeOptions - Whether to encode the options
     * @returns The constructed URL
     */
    async _buildTableUrl(tableName, connectionReference, options = '', encodeOptions = true) {
        const dataSourceInfo = await this._connectionsService.getDataSource(tableName);
        const isSharedSql = (connectionReference.apiId ?? '').indexOf('shared_sql') > -1;
        const isSharePoint = (connectionReference.apiId ?? '').indexOf('shared_sharepointonline') > -1;
        const urlBuilder = {
            runtimeUrl: connectionReference.runtimeUrl ?? '',
            connectionName: connectionReference.connectionName ?? '',
            datasetName: connectionReference.datasetName
                ? isSharedSql
                    ? connectionReference.datasetNameOverride
                    : isSharePoint
                        ? encodeURIComponent(encodeURIComponent(connectionReference.datasetName))
                        : encodeURIComponent(connectionReference.datasetName)
                : '',
            tableId: isSharedSql
                ? encodeURIComponent(encodeURIComponent(dataSourceInfo.tableId))
                : dataSourceInfo.tableId,
            version: dataSourceInfo.version,
            isSharedSql,
        };
        return this._constructUrl(urlBuilder, options, encodeOptions);
    }
    /**
     * Builds the operation URL
     */
    async _buildOperationUrl(operation, config) {
        const operationName = operation.connectorOperation?.operationName;
        if (!operationName) {
            throw new Error(`${DataOperationErrorMessages.InvalidOperationParameters}: ${DataOperationErrorMessages.MissingOperationName}`);
        }
        const dataSourceInfo = await this._connectionsService.getDataSource(config.tableName);
        const isSharedSql = (config.apiId ?? '').indexOf('shared_sql') > -1;
        const path = dataSourceInfo.apis[operationName].path;
        if (isSharedSql) {
            return this._buildSharedSqlOperationUrl(config, path);
        }
        return this._buildStandardOperationUrl(operation, config, operationName, path);
    }
    /**
     * Gets the connection references
     */
    async _getConnectionReferencesAsync() {
        if (this._connectionReferences) {
            return this._connectionReferences;
        }
        const metadataClient = await this._getMetadataClient();
        const response = await metadataClient.getAppConnectionConfigsAsync();
        this._connectionReferences = response.data;
        return this._connectionReferences;
    }
    /**
     * Gets the database references
     */
    async _getDatabaseReferencesAsync() {
        if (this._databaseReferences) {
            return this._databaseReferences;
        }
        const metadataClient = await this._getMetadataClient();
        const response = await metadataClient.getAppDataSourceConfigsAsync();
        this._databaseReferences = response.data;
        return this._databaseReferences;
    }
    /**
     * Gets the metadata client instance
     */
    async _getMetadataClient() {
        const metadataClient = await this._clientProvider.getMetadataClientAsync();
        if (!metadataClient) {
            throw new PowerDataRuntimeError(ErrorCodes.MetadataClientNotAvailable);
        }
        return metadataClient;
    }
    /**
     * Gets the connection reference for a table
     */
    _getConnectionReference(tableName) {
        const connectionReference = this._connectionReferences?.[tableName];
        if (!connectionReference) {
            throw new PowerDataRuntimeError(ErrorCodes.ConnectionReferenceNotFound, tableName);
        }
        return connectionReference;
    }
    /**
     * Gets both the data client and connection reference
     */
    async _getClientsAndConnection(tableName) {
        await this._getReferences();
        const dataClient = await this._clientProvider.getDataClientAsync();
        if (!dataClient) {
            throw new PowerDataRuntimeError(ErrorCodes.DataClientNotAvailable);
        }
        const connectionReference = this._getConnectionReference(tableName);
        return { dataClient, connectionReference };
    }
    /**
     * Builds the URL for shared SQL operations
     */
    _buildSharedSqlOperationUrl(config, path) {
        const version = config.version ? `/${config.version}/` : '/';
        return `${config.runtimeUrl}/${config.connectionName}${version}datasets/${config.datasetName}/procedures${path}`;
    }
    /**
     * Builds the URL for standard operations
     * Assumptions / Invariants:
     *  - The connector always defines a required path parameter for the connection id named 'connectionId'.
     *  - When a dataset is applicable, the parameter name is 'dataset'.
     *  - When a table is applicable, the parameter name is 'tableName'.
     *  - A lone string parameter maps to the first remaining (non-synthetic) required API parameter.
     *  - Array parameters map positionally to the remaining API parameters after filtering.
     *  - Object parameters map by (case-insensitive, hyphen/underscore agnostic) key.
     * @param operation - The data operation containing connector operation details from runtime
     * @param config - The connector operation configuration
     * @param operationName - The name of the operation to be performed
     * @param path - The path template for the operation
     */
    async _buildStandardOperationUrl(operation, config, operationName, path) {
        const dataSourceInfo = await this._connectionsService.getDataSource(config.tableName);
        let apiParams = dataSourceInfo.apis[operationName]?.parameters || [];
        if (apiParams.length > 0) {
            // remove special/synthetic parameters that the executor handles automatically below
            apiParams = apiParams.filter((param) => param.name !== 'connectionId' && param.name !== 'dataset' && param.name !== 'tableName');
        }
        // Handle parameters that could be an object, array, or string
        const operationParams = operation.connectorOperation?.parameters;
        const rawParamValues = {
            connectionId: config.connectionName,
            dataset: 
            // The dataset name needs to be double encoded for sharepoint, once here and then once in the HTTP pipeline
            // CRUD operations already handle this, so we need to do the same here
            config.apiId.indexOf('shared_sharepointonline') !== -1 && config.datasetName
                ? encodeURIComponent(config.datasetName)
                : config.datasetName,
            tableName: config.tableName,
        };
        // Handle different parameter types
        if (operationParams !== undefined) {
            if (typeof operationParams === 'string') {
                // Handle string parameter - often used for single parameter operations
                if (apiParams.length > 0) {
                    // Map to the first required API parameter or if there are no required parameters, the first parameter
                    const requiredParams = apiParams.filter((param) => param.required);
                    rawParamValues[requiredParams?.[0]?.name ?? apiParams[0].name] = operationParams;
                }
            }
            else if (typeof operationParams === 'object' && !Array.isArray(operationParams)) {
                // Handle object parameters - match by parameter name (normalized)
                apiParams.forEach((param) => {
                    if (operationParams) {
                        const value = this._getNormalizedParamValue(operationParams, param.name);
                        if (value !== undefined) {
                            rawParamValues[param.name] = value;
                        }
                    }
                });
            }
            else if (Array.isArray(operationParams)) {
                // Handle array parameters - match by index
                apiParams.forEach((param, index) => {
                    rawParamValues[param.name] = operationParams[index];
                });
            }
        }
        const { processedPath, queryParams } = this._processParameters(
        // deliberately pass the unfiltered list to _processParameters so path placeholders still see synthetic params.
        dataSourceInfo.apis[operationName]?.parameters || [], rawParamValues, path);
        const separator = queryParams ? (processedPath.includes('?') ? '&' : '?') : '';
        return `${config.runtimeUrl}${processedPath}${separator}${queryParams}`;
    }
    /**
     * Normalizes the parameter name by replacing hyphens with underscores and performs case-insensitive matching
     */
    _getNormalizedParamValue(obj, paramName) {
        const normalizedParamName = paramName.replace(/-/g, '_').toLowerCase();
        const foundKey = Object.keys(obj).find((key) => key.replace(/-/g, '_').toLowerCase() === normalizedParamName);
        return foundKey !== undefined ? obj[foundKey] : undefined;
    }
    /**
     * Processes operation parameters into path and query parameters
     * @param apiParams - The API parameter specifications from the data source info
     * @param rawParamValues - The raw parameter values provided in the operation at runtime
     * @param path - The initial path template
     * @returns An object containing the processed path and query parameters
     */
    _processParameters(apiParams, rawParamValues, path) {
        const usedParams = new Set();
        let processedPath = path;
        const queryParams = [];
        apiParams.forEach((param, index) => {
            const paramValue = rawParamValues[param.name];
            if (paramValue === undefined) {
                return;
            }
            if (param.in === 'path') {
                const placeholder = `{${param.name}}`;
                if (processedPath.includes(placeholder)) {
                    processedPath = processedPath.replace(placeholder, encodeURIComponent(String(paramValue)));
                    usedParams.add(param.name);
                }
            }
            else if (param.in === 'query') {
                queryParams.push(`${encodeURIComponent(param.name)}=${encodeURIComponent(String(paramValue))}`);
                usedParams.add(param.name);
            }
        });
        return {
            processedPath,
            queryParams: queryParams.join('&'),
        };
    }
    /**
     * Gets the operation configuration
     */
    async _getOperationConfig(operation, connectionReference, tableName) {
        if (!operation.connectorOperation) {
            throw new Error(`${DataOperationErrorMessages.InvalidRequest}: ${DataOperationErrorMessages.MissingConnectorOperation}`);
        }
        const dataSourceInfo = await this._connectionsService.getDataSource(tableName);
        const config = {
            tableName,
            apiId: connectionReference.apiId ?? '',
            runtimeUrl: connectionReference.runtimeUrl ?? '',
            connectionName: connectionReference.connectionName ?? '',
            datasetName: connectionReference.datasetName ?? '',
            tableId: dataSourceInfo.tableId,
            version: dataSourceInfo.version,
        };
        return config;
    }
    /**
     * Initializes the clients
     */
    async _getReferences() {
        await this._getConnectionReferencesAsync();
        await this._getDatabaseReferencesAsync();
    }
    /**
     * Validates constructor parameters
     */
    _validateConstructorParams(clientProvider, connectionsService) {
        if (!clientProvider) {
            throw new PowerDataRuntimeError(ErrorCodes.ClientProviderNotAvailable);
        }
        if (!connectionsService) {
            throw new PowerDataRuntimeError(ErrorCodes.DataSourceServiceNotAvailable);
        }
    }
    /**
     * Constructs the final URL
     */
    _constructUrl(urlBuilder, options = '', encodeOptions = true) {
        const apiVersion = urlBuilder.version ? `/${urlBuilder.version}/` : '/';
        const encodedOptions = encodeOptions && options ? options.charAt(0) + encodeURIComponent(options.slice(1)) : options;
        if (urlBuilder.datasetName) {
            return `${urlBuilder.runtimeUrl}/${urlBuilder.connectionName}${apiVersion}datasets/${urlBuilder.datasetName}/tables/${urlBuilder.tableId}/items${encodedOptions}`;
        }
        return `${urlBuilder.runtimeUrl}/${urlBuilder.connectionName}/tables/${urlBuilder.tableId}/items${encodedOptions}`;
    }
}
//# sourceMappingURL=connectorDataOperationExecutor.js.map