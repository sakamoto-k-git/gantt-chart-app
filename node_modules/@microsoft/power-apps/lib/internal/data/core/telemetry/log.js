/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
const ServiceName = 'PublishedAppTelemetry';
var TelemetryActionNames;
(function (TelemetryActionNames) {
    TelemetryActionNames["trackEvent"] = "trackEvent";
    TelemetryActionNames["trackException"] = "trackException";
    TelemetryActionNames["trackMetric"] = "trackMetric";
    TelemetryActionNames["startScenario"] = "startScenario";
    TelemetryActionNames["endScenario"] = "endScenario";
    TelemetryActionNames["setDefaultProperties"] = "setDefaultProperties";
})(TelemetryActionNames || (TelemetryActionNames = {}));
export class Log {
    _powerOperationExecutor;
    static _instance = null;
    constructor(_powerOperationExecutor) {
        this._powerOperationExecutor = _powerOperationExecutor;
    }
    static createInstance(powerOperationExecutor) {
        if (!Log._instance) {
            Log._instance = new Log(powerOperationExecutor);
        }
        else {
            Log.trackEvent('TelemetryLogger', {
                message: 'Attempted to create an instance when instance is already created.',
            });
        }
        return Log._instance;
    }
    // Since powerDataRuntime can be reset, we need to be able to reset the instance of Log as well.
    static resetInstance() {
        Log._instance = null;
    }
    static async _sendMessage(actionName, ...args) {
        try {
            const instance = Log._getInstance();
            const result = await instance._powerOperationExecutor.execute(ServiceName, actionName, args);
            if (!result.success) {
                // Fallback to console logging if telemetry fails, since it is reasonable to assume the runtimeClient is failing.
                // eslint-disable-next-line no-console
                console.error({
                    message: `PowerDataRuntime.TelemetryLogger: Failed to send telemetry message.`,
                    error: result.error,
                    telemetryArgs: args,
                });
            }
        }
        catch (error) {
            // Fallback to console logging if telemetry fails, since it is reasonable to assume the runtimeClient is failing.
            // we don't want to throw an error here, since we don't want to break the app if telemetry fails.
            // eslint-disable-next-line no-console
            console.error({
                message: `PowerDataRuntime.TelemetryLogger: Failed to send telemetry message.`,
                error,
                telemetryArgs: args,
            });
        }
    }
    static trackEvent(eventName, eventData) {
        return Log._sendMessage(TelemetryActionNames.trackEvent, `PowerDataRuntime.${eventName}`, eventData);
    }
    static trackException(exception) {
        return Log._sendMessage(TelemetryActionNames.trackException, exception);
    }
    static trackMetric(metricName, value) {
        return Log._sendMessage(TelemetryActionNames.trackMetric, `PowerDataRuntime.${metricName}`, value);
    }
    static startScenario(scenarioName) {
        return Log._sendMessage(TelemetryActionNames.startScenario, `PowerDataRuntime.${scenarioName}`);
    }
    static endScenario(scenarioName) {
        return Log._sendMessage(TelemetryActionNames.endScenario, `PowerDataRuntime.${scenarioName}`);
    }
    static setDefaultProperties(properties) {
        return Log._sendMessage(TelemetryActionNames.setDefaultProperties, properties);
    }
    static _getInstance() {
        if (!Log._instance) {
            throw new Error('PowerDataRuntime.TelemetryLogger: Attempted to log telemetry prior to instantiation.');
        }
        return Log._instance;
    }
}
//# sourceMappingURL=log.js.map