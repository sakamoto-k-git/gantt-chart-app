/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { executePluginAsync } from '../plugin/PluginCommon';
import { SendMessageOperation } from './SendMessageOperation';
export class CompatibleMessageReceiver {
    _receiverName;
    versionInfo;
    isCompatible = true;
    constructor(_receiverName, versionInfo) {
        this._receiverName = _receiverName;
        this.versionInfo = versionInfo;
    }
    async sendMessage(message, onMessageReceived) {
        let resolveOperationPromise;
        let rejectOperationPromise;
        const operationPromise = new Promise((resolve, reject) => {
            resolveOperationPromise = resolve;
            rejectOperationPromise = reject;
        });
        const correlationId = crypto.randomUUID();
        const handleMessage = (compatibleReceiverMessage) => {
            try {
                // Ignore any update after the operation has completed, caller cannot receive additional results.
                if (sendMessageOperation.completed) {
                    return;
                }
                if (compatibleReceiverMessage) {
                    // If the message is an intermediate update then call the message handler, otherwise complete the operation.
                    if (compatibleReceiverMessage.isUpdate) {
                        if (sendMessageOperation.onMessageReceived) {
                            try {
                                sendMessageOperation.onMessageReceived(compatibleReceiverMessage.message);
                            }
                            catch (error) {
                                sendMessageOperation.completed = true;
                                rejectOperationPromise(error);
                            }
                        }
                        else {
                            sendMessageOperation.completed = true;
                            rejectOperationPromise(new Error(`Native receiver expected a message handler, but no handler was supplied. Message: ${compatibleReceiverMessage.message}`));
                        }
                    }
                    else {
                        // The callback is the final result, pass it back to the initial caller.
                        sendMessageOperation.completed = true;
                        resolveOperationPromise(compatibleReceiverMessage.message);
                    }
                    return;
                }
            }
            catch {
                // The response isn't parsable, continue to promise completion.
            }
            // The callback is the final result, pass it back to the initial caller
            sendMessageOperation.completed = true;
            resolveOperationPromise(compatibleReceiverMessage.message);
        };
        // Error handler to catch any errors during native execution.
        // When receiving an error forward it to the caller.
        const handleError = (error) => {
            sendMessageOperation.completed = true;
            rejectOperationPromise(error);
        };
        // Create function for sending intermediate updates from the calling context.
        const sendUpdate = (updateMessage) => {
            if (sendMessageOperation.completed) {
                throw new Error('Tried to send update for completed operation.');
            }
            // Call executePluginAsync, but do not register for results.  Any results will be sent back to the original handlers.
            executePluginAsync('SendMessagePlugin', 'sendMessage', [
                this._receiverName,
                updateMessage,
                correlationId,
            ]);
        };
        // Call executePluginAsync to send the native message to react-native, and begin the request.
        const sendMessageOperation = new SendMessageOperation(operationPromise, sendUpdate);
        sendMessageOperation.onMessageReceived = onMessageReceived;
        try {
            await executePluginAsync('SendMessagePlugin', 'sendMessage', [this._receiverName, message, correlationId], (response) => {
                handleMessage(response);
            });
        }
        catch (error) {
            handleError(error);
        }
        // Synchronously return the operation to the caller.
        return sendMessageOperation;
    }
}
//# sourceMappingURL=CompatibleMessageReceiver.js.map