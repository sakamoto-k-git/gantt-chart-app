/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { executePluginAsync as executePluginAsyncMobile, executePlugin as executePluginMobile, initializeMobilePlugins, isMobilePlayer, } from './PluginMobile';
let antiCSRFToken;
let currentCallbackId = 0;
const callbacks = {};
let postMessageSource;
const instanceId = Date.now().toString();
const postMessageQueue = [];
export async function initializePlugins() {
    if (isMobilePlayer()) {
        await initializeMobilePlugins();
    }
    else {
        initializeMessageChannel();
    }
}
export function executePluginAsync(pluginName, pluginAction, params = [], update) {
    if (isMobilePlayer()) {
        return executePluginAsyncMobile(pluginName, pluginAction, params);
    }
    return new Promise((resolve, reject) => {
        const callbackId = getCallbackId(pluginName);
        callbacks[callbackId] = { resolve, reject, update };
        sendMessage({
            isPluginCall: true,
            callbackId,
            service: pluginName,
            action: pluginAction,
            actionArgs: params,
            antiCSRFToken,
        });
    });
}
export function executePlugin(pluginName, pluginAction, params = []) {
    if (isMobilePlayer()) {
        executePluginMobile(pluginName, pluginAction, params);
        return;
    }
    sendMessage({
        isPluginCall: true,
        callbackId: getCallbackId(pluginName),
        service: pluginName,
        action: pluginAction,
        actionArgs: params,
        antiCSRFToken,
    });
}
function initializeMessageChannel() {
    const messageChannel = new window.MessageChannel();
    messageChannel.port1.onmessage = createMessageHandler(messageChannel);
    // eslint-disable-next-line @microsoft/sdl/no-postmessage-star-origin
    window.parent.postMessage({
        messageType: 'initCommunicationWithPort',
        instanceId,
    }, '*', [messageChannel.port2]);
}
function getCallbackId(pluginName) {
    return 'instanceId=' + instanceId + '_' + pluginName + currentCallbackId++;
}
function sendMessage(message) {
    if (!postMessageSource) {
        postMessageQueue.push(message);
    }
    else {
        postMessageSource.postMessage(message);
    }
}
function createMessageHandler(messageChannel) {
    return (messageEvent) => {
        const message = messageEvent.data;
        // Capture only the messages that are sent via the App Host's CommunicationChannel
        // which always provides an isPluginCall boolean value.
        if (message && typeof message.isPluginCall === 'boolean') {
            // message can be either a native plugin call result, or a script to execute
            if (message.isPluginCall) {
                // this is the result of a plugin call, extract the parameters and return them
                const callbackId = message.callbackId;
                const status = message.status;
                const args = message.args;
                const keepCallback = message.keepCallback;
                try {
                    const callback = callbacks[callbackId];
                    if (keepCallback) {
                        if (callback && callback.update) {
                            callback.update(message.args?.[0]);
                        }
                    }
                    else {
                        if (callback) {
                            if (status === 1) {
                                callback.resolve(args[0]);
                            }
                            else if (status !== 0) {
                                callback.reject(args);
                            }
                        }
                        if (!keepCallback) {
                            delete callbacks[callbackId];
                        }
                    }
                }
                catch (error) {
                    // eslint-disable-next-line no-console
                    console.error(error);
                }
            }
        }
        else if (message && message.messageType === 'initCommunication') {
            antiCSRFToken = message.antiCSRFToken;
            postMessageSource = messageChannel.port1;
            if (postMessageSource) {
                for (let i = 0; i < postMessageQueue.length; i++) {
                    // backfill csrf token
                    postMessageQueue[i].antiCSRFToken = antiCSRFToken;
                    postMessageSource.postMessage(postMessageQueue[i]);
                }
            }
        }
    };
}
//# sourceMappingURL=PluginCommon.js.map